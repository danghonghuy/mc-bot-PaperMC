// node_modules/mineflayer-pathfinder/index.js (Phiên bản đầy đủ V4 - Hoàn chỉnh placeBlock logic)
'use strict';

const { performance } = require('perf_hooks');
const AStar = require('./lib/astar');
const Move = require('./lib/move');
const Movements = require('./lib/movements');
const gotoUtil = require('./lib/goto');
const Lock = require('./lib/lock');
const { Vec3 } = require('vec3');
const Physics = require('./lib/physics');
const nbt = require('prismarine-nbt');
const interactableBlocksData = require('./lib/interactable.json'); // Load dữ liệu JSON
const { GoalNear } = require('./lib/goals');

function inject (bot) {
  let jumpPlaceStartTime = null; // Thời điểm bắt đầu thực hiện jump-place
const JUMP_PLACE_TIMEOUT = 2000; 
  const registry = bot.registry;
  const waterType = registry.blocksByName.water?.id;
  const ladderId = registry.blocksByName.ladder?.id;
  const vineId = registry.blocksByName.vine?.id;
  // Tạo Set từ dữ liệu JSON một lần khi inject
  const interactableBlocks = new Set(interactableBlocksData);

  // --- Helper Functions ---
  function isBlockSolid (block) { return block?.boundingBox === 'block' }
  function isBlockLiquid (block) { return block && (block.type === waterType); }
  function isBlockFalling (block) {
    if (!registry || !block) return false;
    const fallingBlockIds = new Set([
        registry.blocksByName.sand?.id, registry.blocksByName.gravel?.id,
        registry.blocksByName.red_sand?.id, registry.blocksByName.dragon_egg?.id,
        registry.blocksByName.anvil?.id, registry.blocksByName.chipped_anvil?.id,
        registry.blocksByName.damaged_anvil?.id,
        // Thêm concrete powder IDs nếu cần
    ].filter(id => id !== undefined));
    return fallingBlockIds.has(block.type);
  }
   function isBlockSafeForRecovery(block) {
       return !block || block.boundingBox === 'empty';
   }
   function isBlockReplaceable (block) { // Hàm helper đơn giản hóa
       if (!block) return true;
       if (!registry) return block.name === 'air'; // Fallback
       return block.name === 'air' || block.name === 'cave_air' || block.name === 'void_air' ||
              block.type === registry.blocksByName.water?.id ||
              block.type === registry.blocksByName.grass?.id ||
              block.type === registry.blocksByName.tall_grass?.id ||
              block.type === registry.blocksByName.fern?.id ||
              block.type === registry.blocksByName.large_fern?.id ||
              block.type === registry.blocksByName.dead_bush?.id ||
              block.type === registry.blocksByName.snow?.id;
   }
  // --- End Helper Functions ---

  let stateMovements = new Movements(bot);
  let stateGoal = null;
  let astarContext = null;
  let astartTimedout = false;
  let dynamicGoal = false;
  let path = [];
  let pathUpdated = false;
  let digging = false;
  let placing = false;
  let placingBlock = null; // Lưu trữ thông tin về khối đang đặt {x, y, z, dx, dy, dz, jump?, requiresSneak?, returnPos?}
  let lastNodeTime = performance.now();
  let returningPos = null;
  let stopPathing = false;
  const physics = new Physics(bot);
  const lockPlaceBlock = new Lock();
  const lockEquipItem = new Lock();
  const lockUseBlock = new Lock();

  let lastPosition;
  let stuckTicks = 0;
  const STUCK_THRESHOLD_TICKS = 40;
  const MIN_MOVE_DIST_SQ = 0.05 * 0.05;
  let recoveryAttempts = 0;
  const MAX_RECOVERY_ATTEMPTS = 5;
  let isRecovering = false;

  const softBlockTypes = new Set();
  ['oak_leaves', 'spruce_leaves', 'birch_leaves', 'jungle_leaves', 'acacia_leaves', 'dark_oak_leaves', 'azalea_leaves', 'flowering_azalea_leaves', 'cherry_leaves',
   'grass', 'tall_grass', 'fern', 'large_fern', 'vine', 'weeping_vines', 'twisting_vines', 'snow'
  ].forEach(name => {
      const block = registry.blocksByName[name];
      if (block) softBlockTypes.add(block.id);
  });

  bot.once('spawn', () => {
    if (!bot.entity) return;
    lastPosition = bot.entity.position.clone();
    lastNodeTime = performance.now();
    // console.debug('[Pathfinder] Bắt đầu giám sát di chuyển.');
    bot.on('physicsTick', monitorMovement);
  });

  bot.pathfinder = {};

  bot.pathfinder.thinkTimeout = 5000;
  bot.pathfinder.tickTimeout = 40;
  bot.pathfinder.searchRadius = -1;
  bot.pathfinder.enablePathShortcut = false;
  bot.pathfinder.LOSWhenPlacingBlocks = true;

  bot.pathfinder.bestHarvestTool = (block) => {
    if (!bot.entity || !block) return null;
    const availableTools = bot.inventory.items();
    const effects = bot.entity.effects;
    let fastest = Number.MAX_VALUE;
    let bestTool = null;
    for (const tool of availableTools) {
      const enchants = (tool && tool.nbt) ? nbt.simplify(tool.nbt).Enchantments : [];
      let digTime = Infinity;
      if(typeof block.digTime === 'function') {
          digTime = block.digTime(tool ? tool.type : null, false, false, false, enchants, effects);
      }
      if (digTime < fastest) {
        fastest = digTime;
        bestTool = tool;
      }
    }
    return bestTool;
  };

  bot.pathfinder.getPathTo = (movements, goal, timeout) => {
    if (!bot.entity) {
        return { status: 'no_path', cost: 0, time: 0, visitedNodes: 0, generatedNodes: 0, path: [] };
    }
    const generator = bot.pathfinder.getPathFromTo(movements, bot.entity.position, goal, { timeout });
    const { value: { result, astarContext: context } } = generator.next();
    astarContext = context;
    return result;
  };

  bot.pathfinder.getPathFromTo = function * (movements, startPos, goal, options = {}) {
    const optimizePath = options.optimizePath ?? true;
    const resetEntityIntersects = options.resetEntityIntersects ?? true;
    const timeout = options.timeout ?? bot.pathfinder.thinkTimeout;
    const tickTimeout = options.tickTimeout ?? bot.pathfinder.tickTimeout;
    const searchRadius = options.searchRadius ?? bot.pathfinder.searchRadius;

    let start;
    if (options.startMove) {
      start = options.startMove;
    } else {
      const p = startPos.floored();
      const dy = startPos.y - p.y;
      const b = bot.blockAt(p);
      const onGround = bot.entity ? bot.entity.onGround : false;
      const emptyBlocksSet = movements?.emptyBlocks ?? new Set(); // Lấy emptyBlocks từ movements nếu có
      const offset = (b && b.type !== undefined && dy > 0.001 && onGround && !emptyBlocksSet.has(b.type)) ? 1 : 0;
      const scaffoldCount = movements?.countScaffoldingItems?.() ?? 0; // Lấy số lượng scaffold
      start = new Move(p.x, p.y + offset, p.z, scaffoldCount, 0);
    }

    if (movements?.allowEntityDetection) {
      if (resetEntityIntersects) {
        movements.clearCollisionIndex?.();
      }
      movements.updateCollisionIndex?.();
    }

    const context = new AStar(start, movements, goal, timeout, tickTimeout, searchRadius);
    let result = context.compute();
    if (optimizePath && result.path) result.path = postProcessPath(result.path);
    yield { result, astarContext: context };

    while (result.status === 'partial') {
      result = context.compute();
      if (optimizePath && result.path) result.path = postProcessPath(result.path);
      yield { result, astarContext: context };
    }
  };

  Object.defineProperties(bot.pathfinder, {
    goal: { get () { return stateGoal; } },
    movements: { get () { return stateMovements; } }
  });

  function detectDiggingStopped () {
    if (digging) {
      digging = false;
      bot.removeAllListeners('diggingAborted', detectDiggingStopped);
      bot.removeAllListeners('diggingCompleted', detectDiggingStopped);
    }
  }

  function resetPath (reason, clearStates = true) {
    if (isRecovering) {
        if(reason !== 'explicit_stop') return;
        isRecovering = false;
    }
    if (!stopPathing && path.length > 0) bot.emit('path_reset', reason);
    path = [];
    if (digging) {
      bot.on('diggingAborted', detectDiggingStopped);
      bot.on('diggingCompleted', detectDiggingStopped);
      bot.stopDigging();
      digging = false;
    }
    if (placing) {
        placing = false;
        placingBlock = null;
    }
    jumpPlaceStartTime = null; // Reset timer jump-pla
    pathUpdated = false;
    astarContext = null;
    astartTimedout = false;
    stuckTicks = 0;
    recoveryAttempts = 0;
    if (bot.entity) { lastPosition = bot.entity.position.clone(); }
    else { lastPosition = null; }
    lockEquipItem.release();
    lockPlaceBlock.release();
    lockUseBlock.release();
    if (stateMovements && typeof stateMovements.clearCollisionIndex === 'function') {
        stateMovements.clearCollisionIndex();
    }
    if (clearStates) bot.clearControlStates();
    if (stopPathing) return stop();
  }

  bot.pathfinder.setGoal = (goal, dynamic = false) => {
    stateGoal = goal;
    dynamicGoal = dynamic;
    if (goal) {
      bot.emit('goal_updated', goal, dynamic);
      resetPath('goal_updated');
    } else {
      resetPath('goal_removed');
    }
  };

  bot.pathfinder.setMovements = (movements) => {
    stateMovements = movements;
    resetPath('movements_updated');
  };

  bot.pathfinder.isMoving = () => path.length > 0 || digging || placing || isRecovering;
  bot.pathfinder.isMining = () => digging;
  bot.pathfinder.isBuilding = () => placing;

  bot.pathfinder.goto = (goal) => {
    if (!bot.entity) return Promise.reject(new Error("Bot has not spawned yet"));
    return gotoUtil(bot, goal);
  };

  bot.pathfinder.stop = () => {
    stopPathing = true;
    resetPath('explicit_stop');
  };

  function postProcessPath (rawPath) {
      if (!bot.entity || !rawPath || rawPath.length === 0) return rawPath;

      for (let i = 0; i < rawPath.length; i++) {
        const curPoint = rawPath[i];
        if (!curPoint || typeof curPoint !== 'object' || curPoint.x === undefined) continue;
        if ((curPoint.toBreak?.length > 0) || (curPoint.toPlace?.length > 0)) continue; // Thêm ?.

        const b = bot.blockAt(new Vec3(curPoint.x, curPoint.y, curPoint.z));
        if (b && (b.type === waterType || ((b.type === ladderId || b.type === vineId) && i + 1 < rawPath.length && rawPath[i + 1]?.y < curPoint.y))) { // Thêm ?.
          curPoint.x = Math.floor(curPoint.x) + 0.5;
          curPoint.y = Math.floor(curPoint.y);
          curPoint.z = Math.floor(curPoint.z) + 0.5;
          continue;
        }
        let np = getPositionOnTopOf(b);
        if (np === null) np = getPositionOnTopOf(bot.blockAt(new Vec3(curPoint.x, curPoint.y - 1, curPoint.z)));

        if (np) {
          curPoint.x = np.x; curPoint.y = np.y; curPoint.z = np.z;
        } else {
          curPoint.x = Math.floor(curPoint.x) + 0.5;
          curPoint.z = Math.floor(curPoint.z) + 0.5;
        }
      }

      if (!bot.pathfinder.enablePathShortcut || stateMovements?.exclusionAreasStep?.length !== 0 || rawPath.length <= 1) return rawPath;

      const newPath = [];
      newPath.push(rawPath[0]);
      let lastNodePos = new Vec3(rawPath[0].x, rawPath[0].y, rawPath[0].z);
      for (let i = 2; i < rawPath.length; i++) {
          const node = rawPath[i];
          if (!node || typeof node !== 'object' || node.x === undefined) continue;
          const nodePos = new Vec3(node.x, node.y, node.z);
          let isStraight = false;
          try { isStraight = physics.canStraightLine(lastNodePos, nodePos); } catch {} // Bắt lỗi nếu có

          if (Math.abs(node.y - lastNodePos.y) > 1.5 || node.toBreak?.length > 0 || node.toPlace?.length > 0 || !isStraight) {
              const prevNode = rawPath[i - 1];
              if(prevNode && typeof prevNode === 'object') {
                 newPath.push(prevNode);
                 lastNodePos = new Vec3(prevNode.x, prevNode.y, prevNode.z);
              }
          }
      }
      const lastRawNode = rawPath[rawPath.length - 1];
      if(lastRawNode && typeof lastRawNode === 'object') newPath.push(lastRawNode);
      return newPath;
  }

  function pathFromPlayer (currentPath) {
      if (!bot.entity || !currentPath || currentPath.length === 0) return;
      let minI = 0;
      let minDistanceSq = Infinity;

      for (let i = 0; i < currentPath.length; i++) {
          const node = currentPath[i];
          if (!node || typeof node !== 'object' || node.x === undefined) continue;
          if (node.toBreak?.length > 0 || node.toPlace?.length > 0) break; // Thêm ?.
          try { // Bọc trong try-catch phòng lỗi Vec3
            const nodeVec = new Vec3(node.x, node.y, node.z);
            const distSq = bot.entity.position.distanceSquared(nodeVec);
            if (distSq < minDistanceSq) { minDistanceSq = distSq; minI = i; }
          } catch {}
      }

      if (minI + 1 < currentPath.length) {
          const n1 = currentPath[minI];
          const n2 = currentPath[minI + 1];
          if (n1 && typeof n1 === 'object' && n2 && typeof n2 === 'object' &&
              (!n1.toBreak || n1.toBreak.length === 0) && (!n1.toPlace || n1.toPlace.length === 0)) {
              try { // Bọc try-catch
                const p = bot.entity.position;
                const n1Vec = new Vec3(n1.x, n1.y, n1.z);
                const n2Vec = new Vec3(n2.x, n2.y, n2.z);
                const dx = n1.x - p.x; const dy = n1.y - p.y; const dz = n1.z - p.z;
                const reachedN1 = Math.abs(dx) <= 0.5 && Math.abs(dz) <= 0.5 && Math.abs(dy) < 1.5;
                const d2Sq = p.distanceSquared(n2Vec);
                const normValue = n1Vec.minus(n2Vec).norm(); // WORKAROUND
                const d12Sq = normValue * normValue;       // WORKAROUND
                if (reachedN1 || d2Sq < d12Sq) minI++;
              } catch {}
          }
      }

      if (minI > 0) {
          currentPath.splice(0, minI);
          lastNodeTime = performance.now();
      }
  }

  function isPositionNearPath (pos, pathToCheck) {
      if (!bot.entity?.position || !pos || !pathToCheck || pathToCheck.length === 0) return false;
      let prevNode = bot.entity.position;
      let posVec;
      try { posVec = (pos instanceof Vec3) ? pos : new Vec3(pos.x, pos.y, pos.z); } catch { return false; }

      for (const node of pathToCheck) {
           if (!node || typeof node !== 'object' || node.x === undefined) continue;
           let nodeVec;
           try { nodeVec = new Vec3(node.x, node.y, node.z); } catch { continue; }
           const pointToCheck = posVec.plus(new Vec3(0.5, 0.5, 0.5));

           if (!(prevNode instanceof Vec3)) {
                try { prevNode = bot.entity.position.clone(); } catch { return false; }
           }

           const closestPoint = closestPointOnLineSegment(pointToCheck, prevNode, nodeVec);
           if (!closestPoint) continue;

           const dx = Math.abs(closestPoint.x - (posVec.x + 0.5));
           const dy = Math.abs(closestPoint.y - (posVec.y + 0.5));
           const dz = Math.abs(closestPoint.z - (posVec.z + 0.5));

           if (dx <= 1 && dy <= 2 && dz <= 1) return true;
           prevNode = nodeVec;
      }
      return false;
  }

  function closestPointOnLineSegment (point, segmentStart, segmentEnd) {
      if (!(point instanceof Vec3) || !(segmentStart instanceof Vec3) || !(segmentEnd instanceof Vec3)) return null;
      let segmentVector;
      try { segmentVector = segmentEnd.minus(segmentStart); } catch { return null; }
      if (!(segmentVector instanceof Vec3)) return null;

      let segmentLengthSq;
      try {
          const normValue = segmentVector.norm(); // WORKAROUND
          segmentLengthSq = normValue * normValue; // WORKAROUND
      } catch { return null; }

      if (segmentLengthSq === 0) return segmentStart.clone();
      let t;
      try { t = (point.minus(segmentStart)).dot(segmentVector) / segmentLengthSq; } catch { return null; }
      t = Math.max(0, Math.min(1, t));
      try { return segmentStart.plus(segmentVector.scaled(t)); } catch { return null; }
  }

  function getPositionOnTopOf (block) {
      if (!block || !block.shapes || block.shapes.length === 0) return null;
      const p = new Vec3(0.5, 0, 0.5); let n = 1; let highestY = 0;
      for (const shape of block.shapes) {
          const y1 = shape[4];
          if (y1 > highestY) {
              highestY = y1; p.x = 0.5 + (shape[0] + shape[3]) / 2; p.y = y1; p.z = 0.5 + (shape[2] + shape[5]) / 2; n = 2;
          } else if (y1 === highestY) { p.x += (shape[0] + shape[3]) / 2; p.z += (shape[2] + shape[5]) / 2; n++; }
      }
      if (n <= 1) { p.x = 0.5; p.z = 0.5; p.y = highestY; } else { p.x /= n; p.z /= n; }
      return block.position.plus(p);
  }

  function fullStop () {
      bot.clearControlStates();
      if (bot.entity?.velocity) { bot.entity.velocity.x = 0; bot.entity.velocity.z = 0; }
  }

  function moveToEdge (refBlockPos, edgeOffset) {
      if (!bot.entity || !refBlockPos || !edgeOffset) return false;
      let targetEdgePos; let targetBlockCenter; let lookTarget;
      try { // Bọc try-catch cho các phép toán Vec3
         targetEdgePos = refBlockPos.offset(edgeOffset.x + 0.5, 1, edgeOffset.z + 0.5);
         const distSq = bot.entity.position.distanceSquared(targetEdgePos);
         if (distSq > 0.3 * 0.3) {
             targetBlockCenter = refBlockPos.offset(0.5, 0.5, 0.5);
             lookTarget = bot.entity.position.plus(bot.entity.position.minus(targetBlockCenter));
             lookTarget.y -= 2;
             bot.lookAt(lookTarget, true);
             bot.setControlState('sneak', true); bot.setControlState('back', true); bot.setControlState('forward', false);
             return false;
         } else {
             bot.setControlState('back', false); bot.setControlState('sneak', true);
             return true;
         }
      } catch (e) {
        // console.error("Error in moveToEdge:", e);
        return false; // Coi như thất bại nếu có lỗi tính toán
      }
  }

  function moveToBlock(pos) {
      if (!bot.entity || !pos) return false;
      const minDistanceSq = 0.1 * 0.1;
      let targetPos;
      try { // Bọc try-catch
         targetPos = ((pos instanceof Vec3) ? pos : new Vec3(pos.x, pos.y, pos.z)).clone().offset(0.5, 0, 0.5);
         targetPos.y = bot.entity.position.y;
         if (bot.entity.position.distanceSquared(targetPos) > minDistanceSq) {
             bot.lookAt(targetPos);
             bot.setControlState('forward', true); bot.setControlState('sneak', false);
             return false;
         }
         bot.setControlState('forward', false);
         return true;
      } catch (e) {
         // console.error("Error in moveToBlock:", e);
         return false;
      }
  }

  function stop () {
      stopPathing = false; stateGoal = null; path = [];
      bot.emit('path_stop'); fullStop();
  }

  bot.on('blockUpdate', (oldBlock, newBlock) => {
    if (isRecovering || !oldBlock || !newBlock || !bot.entity) return;
    if (oldBlock.type !== newBlock.type) {
      if (isPositionNearPath(oldBlock.position, path)) resetPath('block_updated', false);
    }
  });

  bot.on('chunkColumnLoad', (chunkPosVec) => { /* ... code gốc ... */ });

  async function attemptStrongerRecovery() {
      if (isRecovering) return false;
      isRecovering = true;
      console.warn("[Pathfinder Recovery] Bị kẹt! Thử phục hồi mạnh mẽ...");
      const currentPos = bot.entity.position.clone();
      const surroundingOffsets = [
          { x: 1, y: 0, z: 0 }, { x: -1, y: 0, z: 0 }, { x: 0, y: 0, z: 1 }, { x: 0, y: 0, z: -1 },
          { x: 1, y: 1, z: 0 }, { x: -1, y: 1, z: 0 }, { x: 0, y: 1, z: 1 }, { x: 0, y: 1, z: -1 },
      ];
      let recoveryActionTaken = false;

      console.debug("[Pathfinder Recovery] Bước 1: Kiểm tra khối mềm xung quanh...");
      for (const offset of surroundingOffsets) {
          if (recoveryActionTaken) break; // Đã hành động, không cần check tiếp
          const checkPos = currentPos.plus(offset);
          const block = bot.blockAt(checkPos);
          if (block && softBlockTypes.has(block.type)) {
              console.debug(`[Pathfinder Recovery] Thấy khối mềm (${block.name}) tại ${checkPos}.`);
              try {
                  let safeToBreakRecovery = true;
                  if (stateMovements?.dontMineUnderFallingBlock) {
                      const blockAbove = bot.blockAt(checkPos.offset(0, 1, 0));
                      if (isBlockFalling(blockAbove)) safeToBreakRecovery = false;
                  }
                  if (stateMovements?.dontCreateFlow) {
                       if ([{x:0,y:1,z:0},{x:1,y:0,z:0},{x:-1,y:0,z:0},{x:0,y:0,z:1},{x:0,y:0,z:-1}]
                           .some(off => isBlockLiquid(bot.blockAt(checkPos.plus(off))))) {
                           safeToBreakRecovery = false;
                       }
                  }
                  if (safeToBreakRecovery && bot.canDigBlock(block)) {
                      console.debug(`[Pathfinder Recovery] Thử phá ${block.name}...`);
                      await bot.dig(block);
                      console.log(`[Pathfinder Recovery] Đã phá khối mềm ${block.name}.`);
                      await bot.waitForTicks(5);
                      recoveryActionTaken = true;
                  }
              } catch (digErr) {
                  console.warn(`[Pathfinder Recovery] Lỗi phá khối mềm ${block.name}: ${digErr.message}`);
              }
          }
      }

      let movedSuccessfully = false;
      if (!recoveryActionTaken) {
          console.debug("[Pathfinder Recovery] Bước 2: Thử di chuyển ngẫu nhiên...");
          for (let attempt = 0; attempt < 5; attempt++) {
              if (recoveryActionTaken) break; // Đã hành động ở lần thử trước
              const randomAngle = Math.random() * Math.PI * 2;
              const randomDist = 2 + Math.random() * 2;
              const dx = Math.cos(randomAngle) * randomDist;
              const dz = Math.sin(randomAngle) * randomDist;
              const targetPos = currentPos.offset(dx, 0, dz).floored();
              const blockAtTarget = bot.blockAt(targetPos);
              const blockBelowTarget = bot.blockAt(targetPos.offset(0, -1, 0));
              const targetIsSafe = isBlockSafeForRecovery(blockAtTarget);
              const belowIsSolid = isBlockSolid(blockBelowTarget);
              const noEntities = stateMovements?.getNumEntitiesAt?.(targetPos, 0, 0, 0) === 0 ?? true;

              if (targetIsSafe && belowIsSolid && noEntities) {
                  console.log(`[Pathfinder Recovery] Thấy vị trí an toàn ${targetPos}. Thử goto...`);
                  const recoveryGoal = new GoalNear(targetPos.x, targetPos.y, targetPos.z, 0.5);
                  const gotoPromise = bot.pathfinder.goto(recoveryGoal);
                  const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Recovery goto timed out')), 3000));
                  try {
                      await Promise.race([gotoPromise, timeoutPromise]);
                      console.log("[Pathfinder Recovery] Di chuyển ngẫu nhiên thành công!");
                      movedSuccessfully = true;
                      recoveryActionTaken = true;
                  } catch (gotoErr) {
                      console.warn(`[Pathfinder Recovery] Lỗi/timeout goto ngẫu nhiên: ${gotoErr.message}`);
                  } finally {
                      if (bot.pathfinder.isMoving()) bot.pathfinder.stop();
                      bot.pathfinder.setGoal(null);
                  }
              }
          }
           if (!movedSuccessfully) console.warn("[Pathfinder Recovery] Không thể di chuyển ngẫu nhiên.");
      }

      isRecovering = false;
      console.debug("[Pathfinder Recovery] Kết thúc phục hồi.");
      return recoveryActionTaken;
  }


   // =======================================================================
  // ====================== HÀM CHÍNH ĐIỀU KHIỂN BOT =======================
  // =======================================================================
  function monitorMovement () {
    // Kiểm tra ban đầu chặt chẽ hơn
    if (!bot.entity?.position || !lastPosition || isRecovering || stopPathing) {
        // if(isRecovering) console.debug("[Pathfinder] Monitor skipped: Recovering");
        // else if(stopPathing) console.debug("[Pathfinder] Monitor skipped: Stop requested");
        // else console.debug("[Pathfinder] Monitor skipped: Bot not ready");
        return;
    }

    // --- Xử lý Mục tiêu ---
    if (stateGoal) {
        if (!stateGoal.isValid()) {
            console.warn('[Pathfinder] Mục tiêu không còn hợp lệ.');
            stop(); return;
        } else if (dynamicGoal && stateGoal.hasChanged()) {
            resetPath('goal_moved', false);
            // Sau khi reset, nên return để tick sau tính lại đường
            return;
        }
    } else { // Không có mục tiêu
        if (path.length === 0 && !digging && !placing && !returningPos) {
            // Không có mục tiêu, không có đường đi, không đào/đặt -> không làm gì cả
            return;
        }
        // Nếu có path hoặc đang đào/đặt thì vẫn tiếp tục xử lý bên dưới
    }

    // --- Tiếp tục tính toán A* ---
    if (astarContext && astartTimedout && !digging && !placing && !returningPos) {
      // console.debug('[Pathfinder] Tiếp tục tính toán A* bị tạm dừng...');
      const results = astarContext.compute();
      results.path = postProcessPath(results.path);
      path = results.path ?? []; // Đảm bảo path là array
      astartTimedout = results.status === 'partial';
      pathUpdated = true;
      pathFromPlayer(path);
      bot.emit('path_update', results);
      // console.debug(`[Pathfinder] Tiếp tục tính toán xong. Trạng thái: ${results.status}. Còn lại ${path.length} điểm.`);
      if (path.length === 0 && !astartTimedout && (!stateGoal || !stateGoal.isEnd(bot.entity.position.floored()))) {
          // console.warn("[Pathfinder] Tính toán lại đường đi không tìm thấy điểm nào nhưng chưa đến đích.");
          resetPath('recalc_failed_no_nodes');
          return;
      }
    }

    // --- Quay lại vị trí sau khi đặt khối ---
    if (bot.pathfinder.LOSWhenPlacingBlocks && returningPos) {
      if (!moveToBlock(returningPos)) return;
      returningPos = null;
    }

    // --- Tính toán đường đi mới nếu cần ---
    if (path.length === 0 && !digging && !placing && !returningPos) {
      lastNodeTime = performance.now();
      if (stateGoal && stateMovements) {
        const currentPosFloored = bot.entity.position.floored();
        if (stateGoal.isEnd(currentPosFloored) || stateGoal.isEnd(currentPosFloored.offset(0,-1,0))) {
          if (!dynamicGoal) {
            console.info('[Pathfinder] Đã đến mục tiêu!');
            stop(); // Dừng trước khi emit và xóa goal
            bot.emit('goal_reached', stateGoal);
            stateGoal = null;
          } else {
              // console.debug('[Pathfinder] Đã ở gần mục tiêu động.');
              fullStop();
          }
          return;
        } else if (!pathUpdated && !astarContext) { // Chỉ tính nếu chưa cập nhật VÀ không có context A* cũ
          // console.debug('[Pathfinder] Chưa đến đích, bắt đầu tính đường đi mới...');
          const results = bot.pathfinder.getPathTo(stateMovements, stateGoal);
          path = results.path ?? [];
          astartTimedout = results.status === 'partial';
          pathUpdated = true;
          pathFromPlayer(path);
          bot.emit('path_update', results);
          if (path.length > 0) {
            // console.debug(`[Pathfinder] Tìm thấy đường đi mới với ${path.length} điểm. Trạng thái: ${results.status}`);
            lastNodeTime = performance.now();
            stuckTicks = 0;
            recoveryAttempts = 0;
          } else if (!astartTimedout) {
             // console.warn(`[Pathfinder] Không tìm được đường đi đến mục tiêu. Trạng thái: ${results.status}`);
             bot.emit('path_could_not_reach');
          }
        }
      }
    }

    // --- Nếu vẫn không có đường đi sau các bước trên -> thoát ---
    if (path.length === 0 && !digging && !placing && !returningPos) {
      return;
    }

    // --- Bắt đầu xử lý di chuyển theo đường đi ---
    // Chỉ thực hiện nếu có đường đi và không đang làm việc khác
    if (path.length > 0 && !digging && !placing && !returningPos) {
      let nextPoint = path[0]; // <<< ĐÃ SỬA: let thay vì const
      // Kiểm tra nextPoint hợp lệ
      if (!nextPoint || typeof nextPoint !== 'object' || nextPoint.x === undefined) {
          console.error("[Pathfinder] Điểm tiếp theo không hợp lệ:", nextPoint);
          resetPath('invalid_next_node');
          return;
      }

      const p = bot.entity.position;

      // ----- Xử lý Đào Khối -----
      if (nextPoint.toBreak?.length > 0) { // Thêm ?.
          // console.debug("[Pathfinder] Next node requires breaking blocks.");
          bot.clearControlStates();
          if (!digging && bot.entity.onGround) {
              digging = true;
              const breakTargetRaw = nextPoint.toBreak[0];
              if (!breakTargetRaw || typeof breakTargetRaw !== 'object') { nextPoint.toBreak.shift(); digging = false; return; }
              const breakTarget = new Vec3(breakTargetRaw.x, breakTargetRaw.y, breakTargetRaw.z);
              const blockToDig = bot.blockAt(breakTarget, false);

              if (!blockToDig || blockToDig.type === 0) {
                  // console.debug("[Pathfinder] Khối cần đào đã biến mất.");
                  nextPoint.toBreak.shift(); digging = false; lastNodeTime = performance.now(); return;
              }
              const tool = bot.pathfinder.bestHarvestTool(blockToDig);
              fullStop();

              const startDigging = () => {
                  bot.dig(blockToDig, true, 'raycast')
                      .then(() => {
                          // console.debug(`[Pathfinder] Đào xong ${blockToDig.name}.`);
                          lastNodeTime = performance.now();
                          if(nextPoint.toBreak) nextPoint.toBreak.shift(); // Kiểm tra trước khi shift
                          digging = false;
                      })
                      .catch(err => {
                          console.error(`[Pathfinder] Lỗi đào ${blockToDig.name}: ${err.message}`);
                          // Kiểm tra xem block còn đó không sau lỗi
                          const blockAfter = bot.blockAt(breakTarget, false);
                          if (!blockAfter || blockAfter.type !== blockToDig.type) {
                               console.warn("[Pathfinder] Khối đã biến mất sau lỗi đào. Coi như hoàn thành.");
                               if(nextPoint.toBreak) nextPoint.toBreak.shift();
                               digging = false;
                               lastNodeTime = performance.now();
                          } else {
                               resetPath('dig_error'); // Lỗi thực sự, reset
                          }
                      });
              };

              if (tool && bot.heldItem?.type !== tool.type) {
                  if (!lockEquipItem.tryAcquire()) return;
                  bot.equip(tool, 'hand')
                      .then(() => { lockEquipItem.release(); startDigging(); })
                      .catch(err => { lockEquipItem.release(); resetPath('equip_error_dig'); });
              } else {
                  startDigging();
              }
          }
          return; // Đang đào hoặc chuẩn bị, không làm gì khác
      }

      // ----- Xử lý Đặt Khối -----
      if (nextPoint.toPlace?.length > 0) { // Thêm ?.
          // console.debug("[Pathfinder] Next node requires placing/using blocks.");
          bot.clearControlStates();
          if (!placing) {
              placing = true;
              placingBlock = nextPoint.toPlace[0]; // Lấy thông tin
              if (!placingBlock || typeof placingBlock !== 'object') { nextPoint.toPlace.shift(); placing = false; return; }
              fullStop();
              jumpPlaceStartTime = null; // Reset timer khi bắt đầu hành động đặt mới
          }

          // Xử lý useOne (kích hoạt khối)
          if (placingBlock.useOne) {
              if (!lockUseBlock.tryAcquire()) return;
              const blockToUsePos = new Vec3(placingBlock.x, placingBlock.y, placingBlock.z);
              const blockToUse = bot.blockAt(blockToUsePos);
              if (!blockToUse) {
                 // console.warn(`[Pathfinder] Use target block not found at ${blockToUsePos}`);
                 lockUseBlock.release(); nextPoint.toPlace.shift(); placing = false; lastNodeTime = performance.now(); return;
              }
              bot.activateBlock(blockToUse)
                  .then(() => {
                      // console.debug(`[Pathfinder] Used block ${blockToUse.name}.`);
                      if(nextPoint.toPlace) nextPoint.toPlace.shift();
                      placing = false; lastNodeTime = performance.now();
                      placingBlock = null; // Reset cả placingBlock khi thành công
                  })
                  .catch(err => { resetPath('use_block_error'); })
                  .finally(() => {
                      lockUseBlock.release();
                      // Reset nếu trạng thái vẫn là placing (ví dụ do lỗi không reset path)
                      if (placing) { placing = false; placingBlock = null; lastNodeTime = performance.now(); }
                  });
              return; // Đang sử dụng, không làm gì khác
          }

          // Xử lý đặt khối xây dựng
          const scaffoldingItem = stateMovements.getScaffoldingItem();
          if (!scaffoldingItem) { resetPath('no_scaffolding_blocks'); return; }

          const placeDown = placingBlock.dy === -1 || (placingBlock.y < bot.entity.position.y - 1.1 && placingBlock.dy === 0);
          const requiresSneakExplicit = placingBlock.requiresSneak === true;
          const requireEdge = bot.pathfinder.LOSWhenPlacingBlocks && placeDown;
          let needToSneak = requiresSneakExplicit;
          if (requireEdge) {
              const refBlockVec = new Vec3(placingBlock.x, placingBlock.y, placingBlock.z);
              const edgeVec = new Vec3(placingBlock.dx, 0, placingBlock.dz);
              if (!moveToEdge(refBlockVec, edgeVec)) return;
              needToSneak = true;
          } else if (!needToSneak) {
              const refBlockCheckPos = new Vec3(placingBlock.x, placingBlock.y, placingBlock.z);
              const refBlockCheck = bot.blockAt(refBlockCheckPos, false);
              if (refBlockCheck && interactableBlocks.has(refBlockCheck.name)) needToSneak = true;
          }
          bot.setControlState('sneak', needToSneak);

         // === XỬ LÝ JUMP-PLACE (Kiểm tra trần trước khi nhảy) ===
         let canPlace = true;
         let isJumpPlacing = false;

         if (placingBlock.jump) { // Nếu kế hoạch yêu cầu nhảy
             isJumpPlacing = true;

             // --- KIỂM TRA TRẦN NGAY TRƯỚC KHI NHẢY ---
             const headPos = bot.entity.position.offset(0, 1, 0); // Vị trí đầu bot
             const ceilingPos = headPos.offset(0, 1, 0); // Vị trí ngay trên đầu (y+2 so với chân)
             const ceilingBlock = bot.blockAt(ceilingPos);

             // Nếu trần KHÔNG trống (có block rắn hoặc không an toàn khác)
             if (ceilingBlock && ceilingBlock.boundingBox !== 'empty') {
                  console.warn(`[Pathfinder] Jump-place bị chặn bởi trần (${ceilingBlock.name}) tại ${formatCoords(ceilingPos)}. Resetting.`);
                  // Thử phá khối trần này nếu nó mềm? (Nâng cao, tạm thời reset)
                  // TODO: Có thể thêm logic gọi đào khối trần ở đây nếu là soft block
                  bot.clearControlStates();
                  placing = false; placingBlock = null; jumpPlaceStartTime = null;
                  resetPath('jump_place_ceiling_blocked');
                  return; // Thoát khỏi monitorMovement
             }
             // --- KẾT THÚC KIỂM TRA TRẦN ---

             // Nếu trần đã trống, mới tiếp tục logic nhảy và timeout
             bot.setControlState('jump', true); // Bật/Giữ trạng thái nhảy
             canPlace = !bot.entity.onGround && bot.entity.position.y > placingBlock.y + 1.1; // Tính toán điều kiện đặt

             // Bắt đầu/Kiểm tra timer timeout
             if (jumpPlaceStartTime === null) {
                 jumpPlaceStartTime = performance.now();
                 // console.debug("[Pathfinder] Bắt đầu timer jump-place (trần đã kiểm tra)...");
             } else {
                 const timeElapsed = performance.now() - jumpPlaceStartTime;
                 if (timeElapsed > JUMP_PLACE_TIMEOUT) {
                     console.warn(`[Pathfinder] Jump-place TIMEOUT (${timeElapsed.toFixed(0)}ms) dù trần trống! Resetting.`);
                     bot.clearControlStates();
                     placing = false; placingBlock = null; jumpPlaceStartTime = null;
                     resetPath('jump_place_timeout');
                     return;
                 }
             }
         } else { // Nếu không phải jump-place
             isJumpPlacing = false;
             jumpPlaceStartTime = null;
             canPlace = true; // Đặt bình thường
         }
         // === KẾT THÚC XỬ LÝ JUMP-PLACE ===

          if (canPlace) {
               // Đặt lại timer khi bắt đầu thực hiện đặt (dù là jump hay không)
               jumpPlaceStartTime = null; // Reset vì sắp đặt được rồi
               // console.debug("[Pathfinder] Điều kiện canPlace=true, chuẩn bị gọi placeBlock...");
              if (!lockEquipItem.tryAcquire()) return;
              bot.equip(scaffoldingItem, 'hand')
                  .then(() => {
                      lockEquipItem.release();
                      const refBlockPos = new Vec3(placingBlock.x, placingBlock.y, placingBlock.z);
                      const refBlock = bot.blockAt(refBlockPos, false);
                      const placeVec = new Vec3(placingBlock.dx, placingBlock.dy, placingBlock.dz);
                      if (!refBlock) { resetPath('place_reference_missing'); return; }
                      if (!requireEdge && !bot.canSeeBlock(refBlock)) { resetPath('place_cannot_see'); return; }

                      if (!lockPlaceBlock.tryAcquire()) return;
                      bot.placeBlock(refBlock, placeVec)
                          .then(() => {
                              // === XỬ LÝ THÀNH CÔNG ĐẦY ĐỦ ===
                              // console.debug(`[Pathfinder] Đặt khối ${scaffoldingItem.name} thành công.`);
                              if (needToSneak && !requireEdge) {
                                   const actualRefBlock = bot.blockAt(refBlockPos, false);
                                   if (!actualRefBlock || !interactableBlocks.has(actualRefBlock.name)) {
                                      bot.setControlState('sneak', false);
                                   }
                              }
                              // Tắt jump KHI THÀNH CÔNG
                              if (placingBlock?.jump) bot.setControlState('jump', false); // Thêm ?.

                              if (bot.pathfinder.LOSWhenPlacingBlocks && placingBlock?.returnPos) { // Thêm ?.
                                  returningPos = placingBlock.returnPos.clone();
                              }
                              if (nextPoint.toPlace?.length > 0) nextPoint.toPlace.shift();

                              // Cập nhật trạng thái KHI THÀNH CÔNG
                              placing = false;
                              placingBlock = null;
                              lastNodeTime = performance.now();
                              jumpPlaceStartTime = null; // Reset timer
                          })
                          .catch(err => {
                             // XỬ LÝ LỖI ĐẦY ĐỦ
                             console.error(`[Pathfinder] Lỗi đặt khối ${scaffoldingItem?.name ?? 'unknown'}: ${err.message}`);
                             const targetPos = refBlock.position.plus(placeVec);
                             const blockAtTarget = bot.blockAt(targetPos);

                             if (blockAtTarget && blockAtTarget.type !== 0 && !isBlockReplaceable(blockAtTarget)) {
                                 console.warn(`[Pathfinder] Khối ${blockAtTarget.name} đã tồn tại. Bỏ qua đặt và coi như hoàn thành bước này.`);
                             
                                 if (nextPoint.toPlace?.length > 0) nextPoint.toPlace.shift();
                                 // Reset trạng thái placing NGAY ĐÂY
                                 placing = false;
                                 // *** THÊM DÒNG NÀY ĐỂ TẮT JUMP ***
                                 if (placingBlock?.jump) { // Nếu đây là hành động jump-place bị lỗi "đã tồn tại"
                                     bot.setControlState('jump', false); // Tắt nhảy đi
                                     console.debug("[Pathfinder] Đã tắt jump do block tồn tại khi jump-place.");
                                 }
                                 // *********************************
                                 lastNodeTime = performance.now(); // Cập nhật thời gian
                                 jumpPlaceStartTime = null; // Reset timer jump-place
                                 // KHÔNG reset path
                                 // Không đặt placingBlock = null ở đây, để finally dọn dẹp nốt nếu cần
                             } else {
                                 // Lỗi khác -> reset path
                                 resetPath('place_error');
                             }
                         })
                          .finally(() => {
                              // === XỬ LÝ FINALLY ĐẦY ĐỦ ===
                              lockPlaceBlock.release(); // Luôn giải phóng lock

                              // Chỉ reset timer nếu hành động chưa hoàn thành/reset
                              if (placing) jumpPlaceStartTime = null;
                              // Không cần reset placing/placingBlock ở đây nữa
                          });
                  })
                  .catch(err => { lockEquipItem.release(); resetPath('equip_error_place'); });
          } else if (isJumpPlacing) {
               // Đang nhảy chờ đặt, logic timeout đã xử lý ở trên
               // console.debug("[Pathfinder] Đang nhảy, chờ đủ điều kiện đặt...");
          }
          return; // Đang đặt/chờ đặt, kết thúc tick
      }

      // ----- Xử lý Di chuyển Thông thường -----
      const nextPointVec = new Vec3(nextPoint.x, nextPoint.y, nextPoint.z);
      let dx = nextPoint.x - p.x; let dy = nextPoint.y - p.y; let dz = nextPoint.z - p.z;
      const xzDistSq = dx * dx + dz * dz;

      // Kiểm tra đến nút
      if (xzDistSq <= 0.35 * 0.35 && Math.abs(dy) < 1.2) {
          // console.debug(`[Pathfinder] Đã đến nút. Còn lại ${path.length -1} điểm.`);
          path.shift();
          lastNodeTime = performance.now(); stuckTicks = 0; recoveryAttempts = 0; // Reset lỗi khi đến nút thành công
          if (path.length === 0) { // Điểm cuối cùng
              const currentPosFloored = bot.entity.position.floored();
               if (stateGoal && (stateGoal.isEnd(currentPosFloored) || stateGoal.isEnd(currentPosFloored.offset(0,-1,0)))) {
                   if (!dynamicGoal) { stop(); bot.emit('goal_reached', stateGoal); stateGoal = null; }
                   else { fullStop(); }
                   return;
               } else { resetPath('path_end_not_goal', false); return; }
          }
          // Chưa phải điểm cuối, chuẩn bị điểm tiếp theo
          const nextNodeRaw = path[0];
          if (!nextNodeRaw || typeof nextNodeRaw !== 'object' || nextNodeRaw.x === undefined) { resetPath('invalid_next_node_after_shift'); return; }
          nextPoint = nextNodeRaw; // Gán lại nextPoint
          // Dừng lại nếu cần đào/đặt
          if ( nextPoint.toBreak?.length > 0 || nextPoint.toPlace?.length > 0 ) { // Thêm ?.
              // console.debug('[Pathfinder] Điểm tiếp theo cần tương tác, dừng lại.');
              fullStop(); return;
          }
          // Cập nhật lại dx, dz cho điểm mới
          dx = nextPoint.x - p.x;
          dz = nextPoint.z - p.z;
      }

      // ----- Điều khiển di chuyển -----
      bot.look(Math.atan2(-dx, -dz), 0, true);
      bot.setControlState('forward', true); bot.setControlState('sprint', false); bot.setControlState('jump', false);

      if (bot.entity.isInWater) { bot.setControlState('jump', true); }
      else {
          if (stateMovements?.allowSprinting) {
              try {
                   const pathVecs = path.map(node => new Vec3(node.x, node.y, node.z));
                   if (physics.canStraightLine(pathVecs, true)) bot.setControlState('sprint', true);
                   else if (physics.canSprintJump(pathVecs)) { bot.setControlState('sprint', true); bot.setControlState('jump', true); }
              } catch {}
          }
          if (!bot.controlState.sprint && stateMovements?.allowParkour) {
              try {
                  if (physics.canWalkJump(path.map(node => new Vec3(node.x, node.y, node.z)))) bot.setControlState('jump', true);
              } catch {}
          }
      }

      // ==============================================
      // === KIỂM TRA VÀ PHỤC HỒI KẸT MỚI ===
      // ==============================================
      const isTryingToMove = bot.controlState.forward || bot.controlState.back || bot.controlState.left || bot.controlState.right;
      if (isTryingToMove) {
          if (bot.entity.position.distanceSquared(lastPosition) < MIN_MOVE_DIST_SQ && !bot.entity.isInWater) {
              stuckTicks++;
              if (stuckTicks > STUCK_THRESHOLD_TICKS) {
                  console.warn(`[Pathfinder] Phát hiện kẹt (${stuckTicks} ticks). Thử phục hồi ${recoveryAttempts + 1}/${MAX_RECOVERY_ATTEMPTS}...`);
                  bot.clearControlStates();
                  stuckTicks = 0; // Reset ngay

                  attemptStrongerRecovery().then(actionTaken => {
                      if (actionTaken) { recoveryAttempts = 0; }
                      else {
                          recoveryAttempts++;
                          if (recoveryAttempts >= MAX_RECOVERY_ATTEMPTS) resetPath('stuck_strong_recovery_failed');
                      }
                  }).catch(recoveryError => { resetPath('stuck_recovery_exception'); });
                  return; // Thoát tick này
              }
          } else { stuckTicks = 0; recoveryAttempts = 0; lastPosition = bot.entity.position.clone(); }
      } else { stuckTicks = 0; recoveryAttempts = 0; lastPosition = bot.entity.position.clone(); }
      // ==============================================
      // === KẾT THÚC KIỂM TRA VÀ PHỤC HỒI KẸT MỚI ===
      // ==============================================

      // ----- Kiểm tra thời gian tối đa giữa các nút -----
      if (performance.now() - lastNodeTime > (bot.pathfinder.thinkTimeout + 3000)) {
          console.error(`[Pathfinder] Timeout di chuyển.`);
          if(!isRecovering && recoveryAttempts < MAX_RECOVERY_ATTEMPTS) {
              console.warn("[Pathfinder] Timeout, thử phục hồi lần cuối...");
              bot.clearControlStates();
              attemptStrongerRecovery().catch(()=>{ resetPath('stuck_timeout_recovery_exception'); });
              lastNodeTime = performance.now(); stuckTicks = 0; recoveryAttempts = MAX_RECOVERY_ATTEMPTS;
              return;
          } else { resetPath('stuck_timeout'); return; }
      }
    } // Kết thúc if (path.length > 0 && !digging ...)
  } // Kết thúc monitorMovement

} // Kết thúc inject

module.exports = {
  pathfinder: inject,
  Movements: require('./lib/movements'),
  goals: require('./lib/goals')
};