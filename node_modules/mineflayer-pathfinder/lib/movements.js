// node_modules/mineflayer-pathfinder/lib/movements.js (Phiên bản cải tiến V3 - Hoàn chỉnh)
const { Vec3 } = require('vec3')
const nbt = require('prismarine-nbt')
const Move = require('./move')

const cardinalDirections = [ { x: -1, z: 0 }, { x: 1, z: 0 }, { x: 0, z: -1 }, { x: 0, z: 1 } ]
const diagonalDirections = [ { x: -1, z: -1 }, { x: -1, z: 1 }, { x: 1, z: -1 }, { x: 1, z: 1 } ]

// ==================================================
// --- Các hàm Helper để kiểm tra thuộc tính Block ---
// ==================================================

function isBlockSolid (block) {
  return block?.boundingBox === 'block'
}

function isBlockLiquid (registry, block) {
  if (!registry || !block) return false;
  // Sử dụng optional chaining ?. để tránh lỗi nếu block không tồn tại trong registry
  return block.type === registry.blocksByName.water?.id || block.type === registry.blocksByName.lava?.id;
}

function isBlockClimbable (registry, block) {
    if (!registry || !block) return false;
    return block.type === registry.blocksByName.ladder?.id ||
           block.type === registry.blocksByName.vine?.id ||
           block.type === registry.blocksByName.scaffolding?.id ||
           block.type === registry.blocksByName.weeping_vines?.id || // Thêm các loại dây leo mới
           block.type === registry.blocksByName.twisting_vines?.id;
}

function isBlockSafe (registry, block, blocksToAvoidSet, carpetsSet) {
  if (!block) return true // Null block (chưa tải?) tạm coi là an toàn để tránh kẹt, nhưng cần cẩn thận
  if (blocksToAvoidSet.has(block.type)) return false // Block nằm trong danh sách cần tránh
  return block.boundingBox === 'empty' || isBlockClimbable(registry, block) || carpetsSet.has(block.type)
}

function isBlockReplaceable (registry, block) {
    if (!block) return true // Null block coi như thay thế được
    if (!registry) return false; // Cần registry để kiểm tra tên
    // Coi là thay thế được nếu là không khí các loại, nước, hoặc các loại cây cỏ không rắn chắc
    return block.name === 'air' || block.name === 'cave_air' || block.name === 'void_air' ||
           block.type === registry.blocksByName.water?.id ||
           block.type === registry.blocksByName.grass?.id || // Cỏ
           block.type === registry.blocksByName.tall_grass?.id || // Cỏ cao
           block.type === registry.blocksByName.fern?.id || // Dương xỉ
           block.type === registry.blocksByName.dead_bush?.id || // Bụi cây khô
           block.type === registry.blocksByName.snow?.id; // Tuyết (lớp mỏng)
           // Có thể thêm các loại cây, hoa khác nếu muốn
}

function getBlockHeight (block) {
    if (!block) return -Infinity; // Trả về giá trị rất nhỏ nếu block null
    let height = block.position.y; // Chiều cao cơ bản là Y của block
    if (block.shapes && block.shapes.length > 0) {
      // Tìm giá trị y1 (chiều cao trên cùng của shape) cao nhất
      let maxY1 = block.position.y; // Khởi tạo bằng Y của block
      for (const shape of block.shapes) {
        maxY1 = Math.max(maxY1, block.position.y + shape[4]);
      }
      height = maxY1;
    } else if(isBlockSolid(block)) {
        // Nếu là solid nhưng không có shape (lỗi?), coi như cao 1 block
        height = block.position.y + 1.0;
    }
    // Nếu không solid và không có shape (air...), height sẽ giữ nguyên là y của block
    return height;
}

function isBlockFalling (registry, block) {
    if (!registry || !block) return false;
    return block.type === registry.blocksByName.sand?.id ||
           block.type === registry.blocksByName.gravel?.id ||
           block.type === registry.blocksByName.red_sand?.id ||
           block.type === registry.blocksByName.concrete_powder?.id // Bột xi măng cũng rơi
           // Thêm các khối rơi khác nếu cần (vd: dragon_egg, anvil?)
}

function isBlockFenceLike (block, fencesSet) {
    // Không cần registry vì fencesSet đã chứa type IDs
    return block && fencesSet.has(block.type)
}

function isBlockOpenable (block, openableSet) {
    // Không cần registry vì openableSet đã chứa block IDs (state IDs?)
    // Quan trọng: openableSet lưu ID trạng thái khối, không phải type ID
    return block && openableSet.has(block.stateId ?? block.id); // Ưu tiên stateId nếu có
}

function isBlockDangerous (registry, block) {
    if (!registry || !block) return false;
    return block.type === registry.blocksByName.lava?.id ||
           block.type === registry.blocksByName.fire?.id ||
           block.type === registry.blocksByName.cactus?.id ||
           block.type === registry.blocksByName.magma_block?.id ||
           block.type === registry.blocksByName.sweet_berry_bush?.id; // Bụi berry cũng gây sát thương
           // Thêm các khối nguy hiểm khác (vd: wither_rose?)
}
// =====================================
// --- Kết thúc Helper Functions ---
// =====================================


class Movements {
  constructor (bot) {
    this.bot = bot
    const registry = bot.registry
    this.registry = registry // Lưu registry để dùng trong helper và các nơi khác

    // --- Chi phí Hành động ---
    this.digCost = 1
    this.placeCost = 1.2
    this.bridgeCost = 3.5
    this.pillarCost = 2.0
    this.liquidCost = 1
    this.entityCost = 1

    // --- Tùy chọn Hành vi ---
    this.canDig = true
    this.dontCreateFlow = true
    this.dontMineUnderFallingBlock = true
    this.allow1by1towers = true
    this.allowFreeMotion = false
    this.allowParkour = true
    this.allowSprinting = true
    this.allowEntityDetection = true

    // --- Danh sách ID/Tên các đối tượng cần quan tâm ---
    this.entitiesToAvoid = new Set() // vd: 'creeper', 'zombie' (nên dùng type thay vì name nếu có thể)
    this.passableEntities = new Set(require('./passableEntities.json'))
    this.interactableBlocks = new Set(require('./interactable.json')) // Dùng để check sneak khi đặt

    this.blocksCantBreak = new Set() // Lưu trữ Type ID
    if (registry.blocksByName.chest) this.blocksCantBreak.add(registry.blocksByName.chest.id)
    if (registry.blocksByName.furnace) this.blocksCantBreak.add(registry.blocksByName.furnace.id)
    if (registry.blocksByName.bedrock) this.blocksCantBreak.add(registry.blocksByName.bedrock.id)
    // ...
    registry.blocksArray.forEach(block => {
      if (block.diggable === false) { this.blocksCantBreak.add(block.id) }
    })

    this.blocksToAvoid = new Set() // Lưu trữ Type ID
    if (registry.blocksByName.fire) this.blocksToAvoid.add(registry.blocksByName.fire.id)
    if (registry.blocksByName.cobweb) this.blocksToAvoid.add(registry.blocksByName.cobweb.id)
    if (registry.blocksByName.sweet_berry_bush) this.blocksToAvoid.add(registry.blocksByName.sweet_berry_bush.id)
    if (registry.blocksByName.cactus) this.blocksToAvoid.add(registry.blocksByName.cactus.id)
    if (registry.blocksByName.lava) this.blocksToAvoid.add(registry.blocksByName.lava.id)
    if (registry.blocksByName.magma_block) this.blocksToAvoid.add(registry.blocksByName.magma_block.id)
    // ...

    // --- Khối Xây dựng ---
    this.scafoldingBlocks = [] // Danh sách Type ID của item, theo thứ tự ƯU TIÊN
    if (registry.itemsByName.dirt) this.scafoldingBlocks.push(registry.itemsByName.dirt.id)
    if (registry.itemsByName.cobblestone) this.scafoldingBlocks.push(registry.itemsByName.cobblestone.id)
    if (registry.itemsByName.netherrack) this.scafoldingBlocks.push(registry.itemsByName.netherrack.id)
    // ...

    // --- Phân loại Block dựa trên Hình dạng và Tính chất khác ---
    const Block = require('prismarine-block')(registry)
    this.fences = new Set() // Lưu trữ Type ID của fence/tường cao
    this.carpets = new Set() // Lưu trữ Type ID của thảm/block thấp
    this.openable = new Set() // Lưu trữ State ID của cổng có thể mở
    registry.blocksArray.forEach(blockInfo => {
      // Lấy đối tượng Block từ trạng thái mặc định (minStateId)
      const block = Block.fromStateId(blockInfo.minStateId, 0);
      if (!block) return; // Bỏ qua nếu không tạo được block

      if (block.shapes && block.shapes.length > 0) {
        const isTall = block.shapes[0][4] > 1;
        // Cửa/cổng không phải là fence, nhưng vẫn có thể cao
        const isDoorLike = block.name.includes('door') || block.name.includes('gate');
        if (isTall && !isDoorLike) this.fences.add(block.type)
        if (block.shapes[0][4] < 0.1) this.carpets.add(block.type)
      }

      // Lưu ID trạng thái của cổng có thể mở
      if (this.interactableBlocks.has(block.name) && block.name.toLowerCase().includes('fence_gate') && !block.name.toLowerCase().includes('iron')) {
        this.openable.add(block.stateId ?? block.id); // Ưu tiên stateId
      }
    })

    this.canOpenDoors = false // Giữ false cho ổn định

    // --- Các Vùng Loại trừ ---
    this.exclusionAreasStep = []
    this.exclusionAreasBreak = []
    this.exclusionAreasPlace = []

    // --- Cài đặt khác ---
    this.maxDropDown = 4
    this.infiniteLiquidDropdownDistance = true

    // --- Cache va chạm Thực thể ---
    this.entityIntersections = {}
  }

  // --- Các hàm tiện ích của Movements ---

  exclusionPlace (blockPos) {
    if (!blockPos || this.exclusionAreasPlace.length === 0) return 0
    let weight = 0
    // TODO: Implement this if needed, requires passing block info
    return weight
  }

  exclusionStep (block) {
    if (!block || this.exclusionAreasStep.length === 0) return 0
    let weight = 0
    for (const a of this.exclusionAreasStep) { weight += a(block) }
    return weight
  }

  exclusionBreak (block) {
    if (!block || this.exclusionAreasBreak.length === 0) return 0
    let weight = 0
    for (const a of this.exclusionAreasBreak) { weight += a(block) }
    return weight
  }

  countScaffoldingItems () {
    let count = 0
    const items = this.bot.inventory.items()
    for (const id of this.scafoldingBlocks) {
      for (const item of items) {
        if (item.type === id) {
          count += item.count
        }
      }
    }
    return count
  }

  getScaffoldingItem () {
    const items = this.bot.inventory.items()
    for (const id of this.scafoldingBlocks) {
      for (const item of items) {
        if (item.type === id) {
          return item
        }
      }
    }
    return null
  }

  clearCollisionIndex () { this.entityIntersections = {} }

  updateCollisionIndex () {
    this.clearCollisionIndex()
    if (!this.allowEntityDetection || !this.bot.entities) return

    for (const ent of Object.values(this.bot.entities)) {
      // Sử dụng ent.type để kiểm tra loại thực thể
      const entType = ent.type // Có thể cần kiểm tra xem bot có hỗ trợ ent.type không
      if (ent === this.bot.entity || !entType) continue

      // Cần kiểm tra xem Set có chứa 'type' không (ví dụ: 'mob', 'object')
      // Hoặc cần mapping từ ent.name sang type nếu API yêu cầu
      const avoidedEnt = this.entitiesToAvoid.has(entType); // Hoặc dùng ent.name nếu cần
      const passableEnt = this.passableEntities.has(entType); // Hoặc dùng ent.name

      if (avoidedEnt || !passableEnt) {
        const pos = ent.position
        const w = (ent.width ?? 0.6) / 2 // Sử dụng giá trị mặc định nếu không có width
        const h = ent.height ?? 1.8 // Sử dụng giá trị mặc định
        const minX = Math.floor(pos.x - w); const maxX = Math.floor(pos.x + w)
        const minY = Math.floor(pos.y); const maxY = Math.floor(pos.y + h)
        const minZ = Math.floor(pos.z - w); const maxZ = Math.floor(pos.z + w)

        const cost = avoidedEnt ? 100 : this.entityCost

        for (let y = minY; y <= maxY; y++) {
          for (let x = minX; x <= maxX; x++) {
            for (let z = minZ; z <= maxZ; z++) {
              const key = `${x},${y},${z}`
              this.entityIntersections[key] = (this.entityIntersections[key] ?? 0) + cost
            }
          }
        }
      }
    }
  }

  getNumEntitiesAt (pos, dx, dy, dz) {
    if (!this.allowEntityDetection || !pos) return 0
    const y = Math.floor(pos.y + dy) // Nên làm tròn floor?
    const x = Math.floor(pos.x + dx)
    const z = Math.floor(pos.z + dz)
    return this.entityIntersections[`${x},${y},${z}`] ?? 0
  }

  // Trả về đối tượng Block gốc từ bot.blockAt hoặc null
  getBlock (pos, dx, dy, dz) {
    if (!pos) return null
    try {
        const targetPos = new Vec3(pos.x + dx, pos.y + dy, pos.z + dz)
        // Giới hạn tọa độ Y để tránh lỗi ngoài thế giới
        if (targetPos.y < this.bot.game.minY || targetPos.y >= this.bot.game.height) {
            return null;
        }
        return this.bot.blockAt(targetPos, false)
    } catch(e) {
        // console.error(`[Movements] Error in getBlock at ${pos?.offset(dx,dy,dz)}: ${e.message}`);
        return null; // Trả về null nếu có lỗi
    }
  }

  safeToBreak (block) {
    if (!this.canDig || !block || block.type === 0) return false
    if (this.blocksCantBreak.has(block.type)) return false
    if (this.exclusionBreak(block) >= 100) return false

    const reg = this.registry;

    if (this.dontCreateFlow) {
      const p = block.position
      if (isBlockLiquid(reg, this.getBlock(p, 0, 1, 0))) return false
      if (isBlockLiquid(reg, this.getBlock(p, -1, 0, 0))) return false
      if (isBlockLiquid(reg, this.getBlock(p, 1, 0, 0))) return false
      if (isBlockLiquid(reg, this.getBlock(p, 0, 0, -1))) return false
      if (isBlockLiquid(reg, this.getBlock(p, 0, 0, 1))) return false
    }

    if (this.dontMineUnderFallingBlock) {
      const blockAbove = this.getBlock(block.position, 0, 1, 0)
      if (isBlockFalling(reg, blockAbove)) {
        // TODO: Kiểm tra xem có block nào khác giữ blockAbove không
        return false // Tạm thời coi là không an toàn
      }
    }
    return true
  }

  // Nhận vào đối tượng Block gốc
  safeOrBreak (block, toBreak) {
    // Nếu block là null (vd: ngoài vùng tải), coi như không thể đi qua/phá
    if (!block) return 100;

    const reg = this.registry;
    let cost = 0
    cost += this.exclusionStep(block)
    cost += this.getNumEntitiesAt(block.position, 0, 0, 0) * this.entityCost

    // Sử dụng helper isSafe
    if (isBlockSafe(reg, block, this.blocksToAvoid, this.carpets)) {
        // Nếu là khối leo được, không cần phá nhưng vẫn tốn chi phí leo? (Hiện tại không thêm)
        return cost
    }

    // Nếu không an toàn, kiểm tra có phá được không
    if (!this.safeToBreak(block)) return 100

    // Nếu phá được:
    toBreak.push(block.position.clone()) // Clone vị trí để tránh tham chiếu

    // Thêm chi phí thực thể ở trên block sắp phá (nếu block đó rắn)
    if (isBlockSolid(block)) {
      cost += this.getNumEntitiesAt(block.position, 0, 1, 0) * this.entityCost
    }

    // Tính chi phí đào
    const tool = this.bot.pathfinder.bestHarvestTool(block) // Truyền block gốc
    const enchants = (tool && tool.nbt) ? nbt.simplify(tool.nbt).Enchantments : []
    const effects = this.bot.entity?.effects
    let digTime = 5; // Mặc định
    if(typeof block.digTime === 'function') {
        digTime = block.digTime(tool ? tool.type : null, false, false, false, enchants, effects);
    } else {
        // console.warn(`[Movements] Block ${block?.name} at ${block?.position} might lack digTime.`);
        // Có thể dựa vào block.hardness nếu có
    }
    const laborCost = (1 + 3 * digTime / 1000) * this.digCost
    cost += laborCost
    cost += this.exclusionBreak(block)

    // Đảm bảo chi phí không âm
    return Math.max(0, cost);
  }

  // --- Các hàm Tính toán Bước đi (getMove...) ---

  getMoveJumpUp (node, dir, neighbors) {
    const reg = this.registry;
    const nodePos = new Vec3(node.x, node.y, node.z); // Dùng Vec3 cho node

    // Lấy thông tin các block cần thiết
    const block0 = this.getBlock(nodePos, 0, -1, 0) // Đang đứng
    const blockN = this.getBlock(nodePos, 0, 0, 0) // Chân hiện tại (thường là air)
    const block1 = this.getBlock(nodePos, 0, 1, 0) // Ngang đầu
    const blockA = this.getBlock(nodePos, 0, 2, 0) // Trên đầu
    const blockC = this.getBlock(nodePos, dir.x, 0, dir.z) // Dưới điểm đến
    const blockB = this.getBlock(nodePos, dir.x, 1, dir.z) // Điểm đến (chân)
    const blockH = this.getBlock(nodePos, dir.x, 2, dir.z) // Trên điểm đến (đầu)

    // Điều kiện cơ bản
    if (!block0 || !isBlockSolid(block0)) return // Phải đứng trên nền rắn
    if (!isBlockSafe(reg, block1, this.blocksToAvoid, this.carpets)) return // Đầu bị chặn
    if (getBlockHeight(blockC) - getBlockHeight(block0) > 1.2) return // Quá cao để nhảy
    if (isBlockLiquid(reg, blockN)) return // Không nhảy từ nước

    let cost = 2 // move cost (move+jump)
    const toBreak = []
    const toPlace = []

    // Kiểm tra thực thể (cần kiểm tra kỹ hơn)
    // Ví dụ: Không nhảy nếu có thực thể ở vị trí B
    if (this.getNumEntitiesAt(blockB?.position, 0, 0, 0) > 0) return;


    // Xử lý block C (nền để nhảy lên B)
    if (!isBlockSolid(blockC)) {
      if (node.remainingBlocks === 0) return // Hết block
      if (this.getNumEntitiesAt(blockC?.position, 0, 0, 0) > 0) return

      const blockD = this.getBlock(nodePos, dir.x, -1, dir.z) // Dưới C
      if (!isBlockSolid(blockD)) { // Lỗ 2 block
        if (node.remainingBlocks <= 1) return
        if (this.getNumEntitiesAt(blockD?.position, 0, 0, 0) > 0) return
        if (blockD && !isBlockReplaceable(reg, blockD)) {
          const breakCostD = this.safeOrBreak(blockD, toBreak)
          if (breakCostD >= 100) return
          cost += breakCostD
        }
        const blockE = this.getBlock(nodePos, dir.x, -2, dir.z);
        if (this.exclusionPlace(blockD?.position) >= 100 || isBlockDangerous(reg, blockE)) return
        cost += this.exclusionPlace(blockD?.position)
        // Tham chiếu là node, hướng là dir, đặt vào vị trí D
        toPlace.push({ x: node.x, y: node.y - 1, z: node.z, dx: dir.x, dy: 0, dz: dir.z, jump: false, requiresSneak: true, returnPos: nodePos.clone() })
        cost += this.placeCost
      }

      // Đặt block C
      if (blockC && !isBlockReplaceable(reg, blockC)) {
        const breakCostC = this.safeOrBreak(blockC, toBreak)
        if (breakCostC >= 100) return
        cost += breakCostC
      }
      if (this.exclusionPlace(blockC?.position) >= 100 || isBlockDangerous(reg, blockD)) return
      cost += this.exclusionPlace(blockC?.position)
      // Tham chiếu là D, hướng lên (0,1,0), đặt vào vị trí C
      toPlace.push({ x: node.x + dir.x, y: node.y - 1, z: node.z + dir.z, dx: 0, dy: 1, dz: 0, jump: false })
      cost += this.placeCost
    }

    // Kiểm tra không gian di chuyển
    let breakCost = this.safeOrBreak(blockA, toBreak) // Chỗ đầu đi qua
    if (breakCost >= 100) return
    cost += breakCost
    breakCost = this.safeOrBreak(blockH, toBreak) // Trần trên điểm đến
    if (breakCost >= 100) return
    cost += breakCost
    breakCost = this.safeOrBreak(blockB, toBreak) // Điểm đến
    if (breakCost >= 100) return
    cost += breakCost

    if (blockB) { // Đảm bảo điểm đến hợp lệ
        neighbors.push(new Move(blockB.position.x, blockB.position.y, blockB.position.z, node.remainingBlocks - toPlace.length, cost, toBreak, toPlace))
    }
  }

  getMoveForward (node, dir, neighbors) {
    const reg = this.registry;
    const nodePos = new Vec3(node.x, node.y, node.z);

    const blockB = this.getBlock(nodePos, dir.x, 1, dir.z) // Đầu điểm đến
    const blockC = this.getBlock(nodePos, dir.x, 0, dir.z) // Chân điểm đến
    const blockD = this.getBlock(nodePos, dir.x, -1, dir.z) // Dưới chân điểm đến
    const blockN = this.getBlock(nodePos, 0, 0, 0); // Chân hiện tại

    let cost = 1
    const toBreak = []
    const toPlace = []

    // Trường hợp 1: Đi bộ bình thường
    if (blockD && isBlockSolid(blockD) && !isBlockLiquid(reg, blockC)) {
      cost += this.exclusionStep(blockC)
      if (cost >= 100) return

      let breakCost = this.safeOrBreak(blockC, toBreak)
      if (breakCost >= 100) return
      cost += breakCost
      breakCost = this.safeOrBreak(blockB, toBreak)
      if (breakCost >= 100) return
      cost += breakCost

      if (this.canOpenDoors && isBlockOpenable(blockC, this.openable) && blockC?.shapes?.length !== 0) {
         toPlace.push({ x: blockC.position.x, y: blockC.position.y, z: blockC.position.z, dx: 0, dy: 0, dz: 0, useOne: true })
         cost += 0.5
      }

      if (isBlockLiquid(reg, blockN)) cost += this.liquidCost

      if(blockC) neighbors.push(new Move(blockC.position.x, blockC.position.y, blockC.position.z, node.remainingBlocks, cost, toBreak, toPlace))
      return
    }

    // Trường hợp 2: Lấp lỗ / Bắc cầu
    // Kiểm tra C có an toàn để đứng vào không (sau khi phá nếu cần)
    const costC = this.safeOrBreak(blockC, toBreak)
    if (costC >= 100) return
    // cost đã bao gồm chi phí phá C nếu cần

    // Kiểm tra B có an toàn không (sau khi phá nếu cần)
    const costB = this.safeOrBreak(blockB, toBreak)
    if (costB >= 100) return
    // cost đã bao gồm chi phí phá B nếu cần


    if (node.remainingBlocks === 0) return
    if (this.getNumEntitiesAt(blockD?.position, 0, 0, 0) > 0) return

    const blockE = this.getBlock(nodePos, dir.x, -2, dir.z)
    if (this.exclusionPlace(blockD?.position) >= 100) return
    if (isBlockDangerous(reg, blockE)) return

    if (blockD && !isBlockReplaceable(reg, blockD)) {
      const breakCostD = this.safeOrBreak(blockD, toBreak) // Tính riêng chi phí phá D
      if (breakCostD >= 100) return
      // Không cộng breakCostD vào cost chính vì nó đã bao gồm trong safeOrBreak nếu D cần phá
    }

    // Xác định bắc cầu dựa trên block D có phải là air/liquid không
    const isBridging = !blockD || blockD.name === 'air' || isBlockLiquid(reg, blockD);

    const requiresSneak = isBridging || isBlockLiquid(reg, blockD) // Cần sneak khi bắc cầu/đặt trên nước
    toPlace.push({
        x: node.x, y: node.y - 1, z: node.z, // Tham chiếu là block dưới chân bot
        dx: dir.x, dy: 0, dz: dir.z,           // Hướng đặt vào vị trí D
        jump: false, requiresSneak: requiresSneak
    })

    // Cập nhật cost chính
    cost += costC // Chi phí phá C (đã tính ở trên)
    cost += costB // Chi phí phá B (đã tính ở trên)
    cost += isBridging ? this.bridgeCost : this.placeCost // Chi phí đặt khối
    if (isBlockLiquid(reg, blockN)) cost += this.liquidCost

    if(blockC) neighbors.push(new Move(blockC.position.x, blockC.position.y, blockC.position.z, node.remainingBlocks - 1, cost, toBreak, toPlace))
  }

  getMoveDiagonal (node, dir, neighbors) {
    const reg = this.registry;
    const nodePos = new Vec3(node.x, node.y, node.z);

    let cost = Math.SQRT2
    const toBreak = []

    const blockC = this.getBlock(nodePos, dir.x, 0, dir.z) // Đích (chân)
    const blockB = this.getBlock(nodePos, dir.x, 1, dir.z) // Đích (đầu)
    const blockC1 = this.getBlock(nodePos, 0, 0, dir.z) // Góc 1 (chân)
    const blockB1 = this.getBlock(nodePos, 0, 1, dir.z) // Góc 1 (đầu)
    const blockC2 = this.getBlock(nodePos, dir.x, 0, 0) // Góc 2 (chân)
    const blockB2 = this.getBlock(nodePos, dir.x, 1, 0) // Góc 2 (đầu)
    const blockD = this.getBlock(nodePos, dir.x, -1, dir.z) // Nền đích
    const blockN = this.getBlock(nodePos, 0, 0, 0); // Chân hiện tại

    // Kiểm tra nền đích
    if (!blockD || (!isBlockSolid(blockD) && !isBlockLiquid(reg, blockC))) return

    // Kiểm tra không gian di chuyển (phá nếu cần)
    let breakCost = this.safeOrBreak(blockC, toBreak)
    if (breakCost >= 100) return
    cost += breakCost
    breakCost = this.safeOrBreak(blockB, toBreak)
    if (breakCost >= 100) return
    cost += breakCost
    breakCost = this.safeOrBreak(blockC1, toBreak)
    if (breakCost >= 100) return
    cost += breakCost
    breakCost = this.safeOrBreak(blockB1, toBreak)
    if (breakCost >= 100) return
    cost += breakCost
    breakCost = this.safeOrBreak(blockC2, toBreak)
    if (breakCost >= 100) return
    cost += breakCost
    breakCost = this.safeOrBreak(blockB2, toBreak)
    if (breakCost >= 100) return
    cost += breakCost

    if (isBlockLiquid(reg, blockN)) cost += this.liquidCost

    if(blockC) neighbors.push(new Move(blockC.position.x, blockC.position.y, blockC.position.z, node.remainingBlocks, cost, toBreak))
  }

  getLandingBlock (node, dir) {
    const reg = this.registry;
    const nodePos = new Vec3(node.x, node.y, node.z);
    let landingBlock = null; // Khối sẽ đáp xuống (chân ở đó)
    let currentY = node.y;

    // Vị trí ngang ban đầu để bắt đầu kiểm tra rơi
    const initialCheckX = node.x + dir.x;
    const initialCheckZ = node.z + dir.z;

    for (let dy = 0; dy <= this.maxDropDown; dy++) {
        const checkY = node.y - dy;
        const currentPos = new Vec3(initialCheckX, checkY, initialCheckZ);

        const blockAtCheck = this.getBlock(currentPos, 0, 0, 0);
        const blockBelow = this.getBlock(currentPos, 0, -1, 0);

        // Kiểm tra an toàn tại điểm rơi (chân)
        if (!isBlockSafe(reg, blockAtCheck, this.blocksToAvoid, this.carpets)) {
            // Nếu không an toàn VÀ không phải rơi vào nước (nếu cho phép)
            if (!(isBlockLiquid(reg, blockAtCheck) && this.infiniteLiquidDropdownDistance)) {
                return null; // Không hạ cánh được
            }
        }

        // Nếu khối bên dưới là rắn chắc HOẶC là nước (nếu cho phép rơi vô hạn)
        if ((blockBelow && isBlockSolid(blockBelow)) || (isBlockLiquid(reg, blockBelow) && this.infiniteLiquidDropdownDistance)) {
            // Kiểm tra thực thể cản trở tại điểm đáp (trừ khi đáp xuống nước)
             if (this.getNumEntitiesAt(blockAtCheck?.position, 0, 0, 0) > 0 && !isBlockLiquid(reg, blockBelow)) {
                 return null; // Có thực thể cản
             }
            landingBlock = blockAtCheck; // Đây là nơi chân sẽ đáp
            break; // Tìm thấy điểm đáp, thoát vòng lặp
        }

        // Nếu khối tại điểm kiểm tra không an toàn (và không phải nước cho phép), dừng tìm kiếm
        if (!isBlockSafe(reg, blockAtCheck, this.blocksToAvoid, this.carpets) && !(isBlockLiquid(reg, blockAtCheck) && this.infiniteLiquidDropdownDistance)) {
            return null;
        }
    }

    return landingBlock; // Trả về block tại điểm đáp hoặc null nếu không tìm thấy
}


  getMoveDropDown (node, dir, neighbors) {
    const reg = this.registry;
    const nodePos = new Vec3(node.x, node.y, node.z);

    const blockC = this.getBlock(nodePos, dir.x, 0, dir.z) // Không gian ngang chân
    const blockB = this.getBlock(nodePos, dir.x, 1, dir.z) // Không gian ngang đầu
    const blockN = this.getBlock(nodePos, 0, 0, 0); // Chân hiện tại

    let cost = 1
    const toBreak = []

    // Phá khối cản ngang
    let breakCost = this.safeOrBreak(blockC, toBreak)
    if (breakCost >= 100) return
    cost += breakCost
    breakCost = this.safeOrBreak(blockB, toBreak)
    if (breakCost >= 100) return
    cost += breakCost

    // Tìm điểm tiếp đất
    const blockLand = this.getLandingBlock(nodePos, dir)
    if (!blockLand) return

    if (isBlockLiquid(reg, blockN)) cost += this.liquidCost
    // cost += (node.y - blockLand.position.y) * 0.1; // Thêm chi phí rơi

    neighbors.push(new Move(blockLand.position.x, blockLand.position.y, blockLand.position.z, node.remainingBlocks, cost, toBreak))
  }

  getMoveDown (node, neighbors) {
    const reg = this.registry;
    const nodePos = new Vec3(node.x, node.y, node.z);
    const blockN = this.getBlock(nodePos, 0, 0, 0); // Chân hiện tại

    // Tìm điểm tiếp đất ngay dưới
    const blockLand = this.getLandingBlock(nodePos, { x: 0, y:0, z: 0 }) // dir = 0
    if (!blockLand) return

    let cost = 1
    const toBreak = []

    // Chỉ cần phá khối ngay dưới chân nếu nó cản đường rơi
    const block0 = this.getBlock(nodePos, 0, -1, 0)
    const breakCost = this.safeOrBreak(block0, toBreak)
    if (breakCost >= 100) return
    cost += breakCost

    if (isBlockLiquid(reg, blockN)) cost += this.liquidCost
    // cost += (node.y - blockLand.position.y) * 0.1; // Thêm chi phí rơi

    neighbors.push(new Move(blockLand.position.x, blockLand.position.y, blockLand.position.z, node.remainingBlocks, cost, toBreak))
  }

  getMoveUp (node, neighbors) {
    const reg = this.registry;
    const nodePos = new Vec3(node.x, node.y, node.z);

    const block0 = this.getBlock(nodePos, 0, -1, 0); // Đang đứng
    const blockN = this.getBlock(nodePos, 0, 0, 0); // Chân hiện tại
    const block1 = this.getBlock(nodePos, 0, 1, 0); // Ngang đầu / Điểm đến
    const blockA = this.getBlock(nodePos, 0, 2, 0); // Trên đầu

    // Điều kiện cơ bản
    if (!block0 || !isBlockSolid(block0)) return;
    if (isBlockLiquid(reg, blockN)) return;
    // Không kiểm tra block1 (điểm đến) ở đây vội, sẽ xử lý sau
    if (this.getNumEntitiesAt(nodePos, 0, 0, 0) > 0) return;

    let cost = 1;
    const toBreak = [];
    const toPlace = [];

    // === KIỂM TRA VÀ LÊN KẾ HOẠCH PHÁ KHỐI CẢN TRỞ ===
    const blocksToCheck = [
        // Khối chắc chắn phải trống hoặc phá được:
        { offset: { x: 0, y: 1, z: 0 }, block: block1, critical: true }, // Điểm đáp (ngang đầu)
        { offset: { x: 0, y: 2, z: 0 }, block: blockA, critical: true }, // Ngay trên đầu

        // Các khối xung quanh ngang đầu (y+1) - quan trọng để đáp xuống
        { offset: { x: 1, y: 1, z: 0 }, block: this.getBlock(nodePos, 1, 1, 0), critical: false },
        { offset: { x: -1, y: 1, z: 0 }, block: this.getBlock(nodePos, -1, 1, 0), critical: false },
        { offset: { x: 0, y: 1, z: 1 }, block: this.getBlock(nodePos, 0, 1, 1), critical: false },
        { offset: { x: 0, y: 1, z: -1 }, block: this.getBlock(nodePos, 0, 1, -1), critical: false },

        // Tùy chọn: Kiểm tra xung quanh y+2 nếu cần không gian nhảy rộng hơn
        // { offset: { x: 1, y: 2, z: 0 }, block: this.getBlock(nodePos, 1, 2, 0), critical: false },
        // ... (thêm các hướng khác cho y+2)
    ];

    for (const item of blocksToCheck) {
        const blockToCheck = item.block;
        // Nếu block tồn tại và không an toàn để đi qua
        if (blockToCheck && !isBlockSafe(reg, blockToCheck, this.blocksToAvoid, this.carpets)) {
            const breakCost = this.safeOrBreak(blockToCheck, toBreak);
            if (breakCost >= 100) {
                // Nếu khối critique (y+1 hoặc y+2 trực tiếp) không thể phá -> hủy hành động
                if (item.critical) {
                    // console.debug(`[Movements getMoveUp] Blocked by critical unbreakable block: ${blockToCheck.name}`);
                    return;
                }
                // Nếu khối xung quanh không phá được, có thể chấp nhận và tăng cost? Hoặc hủy? Tạm thời hủy.
                // console.debug(`[Movements getMoveUp] Blocked by surrounding unbreakable block: ${blockToCheck.name}`);
                return;
            }
            cost += breakCost; // Cộng chi phí phá vào tổng cost
        }
    }
    // === KẾT THÚC KIỂM TRA PHÁ KHỐI ===


    // Nếu không phải khối leo được -> phải đặt block
    if (!isBlockClimbable(reg, blockN)) {
      if (!this.allow1by1towers || node.remainingBlocks === 0) return;
      if (getBlockHeight(block0) < node.y - 0.1) return; // Không nhảy từ slab
      if (this.exclusionPlace(blockN?.position) >= 100 || isBlockDangerous(reg, block0)) return;

      if (blockN && !isBlockReplaceable(reg, blockN)) {
        // Nếu blockN cần phá, nó đã được xử lý trong vòng lặp blocksToCheck ở trên
        // Chỉ cần đảm bảo nó không bị đánh dấu là không thể phá (đã return ở trên nếu vậy)
      }

      cost += this.exclusionPlace(blockN?.position);
      toPlace.push({ x: node.x, y: node.y - 1, z: node.z, dx: 0, dy: 1, dz: 0, jump: true });
      cost += this.pillarCost;
    }

    // Đã kiểm tra và cộng cost phá các khối cản, giờ thêm bước đi cuối cùng
    if(block1) { // Đảm bảo block đích tồn tại
       neighbors.push(new Move(block1.position.x, block1.position.y, block1.position.z, node.remainingBlocks - toPlace.length, cost, toBreak, toPlace));
    } else {
       // console.warn("[Movements getMoveUp] Destination block (y+1) is null?");
    }
  }


  getMoveParkourForward (node, dir, neighbors) {
     if (!this.allowParkour) return

     const reg = this.registry;
     const nodePos = new Vec3(node.x, node.y, node.z);

     const block0 = this.getBlock(nodePos, 0, -1, 0)
     if (!block0 || !isBlockSolid(block0)) return
     if (isBlockLiquid(reg, this.getBlock(nodePos, 0, 0, 0))) return

     // Kiểm tra khoảng trống phía trước
     const blockC1 = this.getBlock(nodePos, dir.x, 0, dir.z)
     const blockB1 = this.getBlock(nodePos, dir.x, 1, dir.z)
     if (!isBlockSafe(reg, blockC1, this.blocksToAvoid, this.carpets) || !isBlockSafe(reg, blockB1, this.blocksToAvoid, this.carpets)) return

     const maxJumpDist = this.allowSprinting ? 4 : 2
     let cost = 1.5 // Parkour base cost
     let lastLandingBlock = null // { pos: Vec3, cost: number }

     for (let dist = 2; dist <= maxJumpDist; dist++) {
       const dx = dir.x * dist
       const dz = dir.z * dist

       const currentX = node.x + dx;
       const currentZ = node.z + dz;

       const blockC = this.getBlock(nodePos, dx, 0, dz) // Chân đáp
       const blockB = this.getBlock(nodePos, dx, 1, dz) // Đầu khi đáp
       const blockD = this.getBlock(nodePos, dx, -1, dz) // Nền dưới điểm đáp

       // Kiểm tra không gian tại điểm đáp
       if (!isBlockSafe(reg, blockC, this.blocksToAvoid, this.carpets) || !isBlockSafe(reg, blockB, this.blocksToAvoid, this.carpets)) {
         break; // Gặp vật cản
       }

       // Kiểm tra trần
       let ceilingClear = true
       for(let i=0; i<=dist; i++) {
           if (!isBlockSafe(reg, this.getBlock(nodePos, dir.x * i, 2, dir.z * i), this.blocksToAvoid, this.carpets)) {
               ceilingClear = false;
               break;
           }
       }
       if (!ceilingClear) break; // Trần thấp

       // Trường hợp 1: Đáp xuống nền (blockD rắn)
       if (blockD && isBlockSolid(blockD)) {
         if (getBlockHeight(blockD) - getBlockHeight(block0) > 1.2) break; // Quá cao
         let landingCost = cost + this.exclusionStep(blockC) + this.getNumEntitiesAt(blockC?.position, 0, 0, 0) * this.entityCost
         if (landingCost < 100 && blockC) { // Đảm bảo blockC tồn tại
            lastLandingBlock = { pos: blockC.position.clone(), cost: landingCost };
         }
         break; // Tìm thấy nền, dừng
       }

       // Trường hợp 2: Rơi xuống 1 block (blockE rắn)
       const blockE = this.getBlock(nodePos, dx, -2, dz)
       if (blockE && isBlockSolid(blockE)) {
          if (node.y - (blockD?.position.y ?? node.y -1) <= this.maxDropDown) { // Kiểm tra độ cao rơi
              let landingCost = cost + this.exclusionStep(blockD) + this.getNumEntitiesAt(blockD?.position, 0, 0, 0) * this.entityCost;
              if (landingCost < 100 && blockD) { // Đảm bảo blockD tồn tại
                  lastLandingBlock = { pos: blockD.position.clone(), cost: landingCost };
              }
          }
          break; // Có nền ở E, dừng
       }

       // Nếu không có nền ở D và E, tiếp tục tìm xa hơn
       cost += 0.1
     }

     if(lastLandingBlock) {
         neighbors.push(new Move(lastLandingBlock.pos.x, lastLandingBlock.pos.y, lastLandingBlock.pos.z, node.remainingBlocks, lastLandingBlock.cost, [], [], true));
     }
  }


  // --- Hàm chính lấy các bước đi tiếp theo ---
  getNeighbors (node) {
    const neighbors = []
    for (const dir of cardinalDirections) {
      this.getMoveForward(node, dir, neighbors)
      this.getMoveJumpUp(node, dir, neighbors)
      this.getMoveDropDown(node, dir, neighbors)
      if (this.allowParkour) {
        this.getMoveParkourForward(node, dir, neighbors)
      }
    }
    for (const dir of diagonalDirections) {
      this.getMoveDiagonal(node, dir, neighbors)
    }
    this.getMoveDown(node, neighbors)
    this.getMoveUp(node, neighbors)
    return neighbors
  }
}

module.exports = Movements