const { GoalBlock, GoalNear } = require("mineflayer-pathfinder").goals;
const { Vec3 } = require("vec3");
const { translateToEnglishId, formatCoords, sleep } = require("../utils");

const CRAFTING_TABLE_ID_NAME = 'crafting_table';
const FURNACE_ID_NAME = 'furnace';
const BLAST_FURNACE_ID_NAME = 'blast_furnace';
const SMOKER_ID_NAME = 'smoker';
const ALL_FURNACE_TYPES = [FURNACE_ID_NAME, BLAST_FURNACE_ID_NAME, SMOKER_ID_NAME];
const COBBLESTONE_ID_NAME = 'cobblestone';
const FUEL_TAG = 'minecraft:coals';
const LOGS_TAG = 'minecraft:logs_that_burn';

const MAX_SEARCH_DIST = 32;

async function findNearbyBlock(bot, mcData, blockNames, maxDistance = MAX_SEARCH_DIST) {
    const blockIds = blockNames
        .map(name => mcData.blocksByName[name]?.id)
        .filter(id => id !== undefined);

    if (blockIds.length === 0) {
        console.error(`[FindBlock] Không tìm thấy dữ liệu block cho: ${blockNames.join(', ')}`);
        return null;
    }
    console.log(`[FindBlock] Tìm ${blockNames.join('/')} gần đó (IDs: ${blockIds.join(', ')}, Tối đa: ${maxDistance} blocks)...`);
    try {
        const foundBlocks = await bot.findBlocks({
            matching: blockIds,
            maxDistance: maxDistance,
            count: 5
        });

        if (foundBlocks.length > 0) {
            foundBlocks.sort((a, b) => bot.entity.position.distanceTo(a) - bot.entity.position.distanceTo(b));
            const closestPos = foundBlocks[0];
            const block = bot.blockAt(closestPos);
            if (block) {
                console.log(`[FindBlock] Tìm thấy ${block.name} gần nhất tại ${formatCoords(block.position)}`);
                return block;
            } else {
                console.warn(`[FindBlock] Tìm thấy vị trí ${formatCoords(closestPos)} nhưng không lấy được block?`);
                return null;
            }
        } else {
            console.log(`[FindBlock] Không tìm thấy ${blockNames.join('/')} nào gần đó.`);
            return null;
        }
    } catch (err) {
        console.error("[FindBlock] Lỗi khi tìm kiếm block:", err);
        return null;
    }
}

async function gotoBlock(bot, targetBlock, reach = 2.5) {
    if (!targetBlock) return false;
    const goal = new GoalNear(targetBlock.position.x, targetBlock.position.y, targetBlock.position.z, reach);
    console.log(`[Goto] Bắt đầu di chuyển đến gần ${targetBlock.name} tại ${formatCoords(targetBlock.position)}...`);
    try {
        await bot.pathfinder.goto(goal);
        console.log(`[Goto] Đã đến gần ${targetBlock.name}.`);
        return true;
    } catch (err) {
        console.error(`[Goto] Lỗi khi di chuyển đến ${targetBlock.name}:`, err.message);
        bot.pathfinder.stop();
        return false;
    }
}

async function ensureCraftingTableInInventory(bot, mcData, username, itemNameVi) {
    const tableItemData = mcData.itemsByName[CRAFTING_TABLE_ID_NAME];
    if (!tableItemData) {
        console.error("[EnsureTable] Không tìm thấy dữ liệu item cho crafting_table!");
        bot.chat(`Lỗi dữ liệu game, không tìm thấy thông tin bàn chế tạo.`);
        return false;
    }
    const tableItemId = tableItemData.id;
    console.log(`[EnsureTable] Kiểm tra BCT (ID: ${tableItemId}) trong túi đồ...`);
    let tableItem = bot.inventory.findInventoryItem(tableItemId, null);
    if (tableItem && tableItem.count > 0) {
        console.log(`[EnsureTable] Tìm thấy ${tableItem.count} BCT trong túi đồ.`);
        return true;
    }
    console.log("[EnsureTable] Không có BCT trong túi đồ. Thử chế tạo...");
    bot.chat(`${username}, tôi không có bàn chế tạo, để tôi thử làm một cái...`);
    const plankItems = mcData.itemsArray.filter(item => item.name.endsWith('_planks'));
    let totalPlanks = 0;
    for (const plank of plankItems) {
        totalPlanks += bot.inventory.count(plank.id, null);
    }
    console.log(`[EnsureTable] Kiểm tra gỗ ván (planks): Có tổng cộng ${totalPlanks}`);
    if (totalPlanks < 4) {
        console.log("[EnsureTable] Không đủ gỗ ván để chế tạo BCT.");
        bot.chat(`Tôi không có đủ gỗ ván (cần 4) để làm bàn chế tạo${itemNameVi ? ` cho ${itemNameVi}`: '.'}`);
        return false;
    }
    const bctRecipes = bot.recipesFor(tableItemId, null, 1, null);
    if (!bctRecipes || bctRecipes.length === 0) {
        console.error("[EnsureTable] Không tìm thấy công thức chế tạo BCT trong bot.recipesFor!");
        bot.chat(`Lạ thật, tôi không biết cách chế tạo bàn chế tạo?`);
        return false;
    }
    const bctRecipe = bctRecipes[0];
    console.log("[EnsureTable] Tìm thấy công thức BCT. Bắt đầu chế tạo...");
    try {
        await bot.craft(bctRecipe, 1, null);
        await bot.waitForTicks(10);
        tableItem = bot.inventory.findInventoryItem(tableItemId, null);
        if (tableItem && tableItem.count > 0) {
            console.log("[EnsureTable] Chế tạo BCT thành công!");
            bot.chat("Tôi đã làm xong bàn chế tạo!");
            return true;
        } else {
            console.error("[EnsureTable] Chế tạo BCT nhưng không thấy trong túi đồ sau đó?");
            bot.chat("Tôi đã thử làm bàn chế tạo nhưng có lỗi gì đó.");
            return false;
        }
    } catch (err) {
        console.error("[EnsureTable] Lỗi khi chế tạo BCT:", err);
        bot.chat(`Tôi gặp lỗi khi cố chế tạo bàn chế tạo: ${err.message}`);
        return false;
    }
}

async function placeBlockFromInventory(bot, mcData, username, blockToPlaceName, ensureFunction) {
    const canPlace = await ensureFunction(bot, mcData, username, blockToPlaceName);
    if (!canPlace) { return null; }

    const blockItemData = mcData.itemsByName[blockToPlaceName];
    const blockItem = bot.inventory.findInventoryItem(blockItemData.id, null);
    if (!blockItem) {
         console.error(`[PlaceBlock] Lỗi logic: Đã đảm bảo có ${blockToPlaceName} nhưng lại không tìm thấy?`);
         bot.chat(`Có lỗi xảy ra, tôi không tìm thấy ${blockToPlaceName} vừa rồi.`);
         return null;
    }

    console.log(`[PlaceBlock] Tìm vị trí thích hợp để đặt ${blockToPlaceName}...`);
    bot.chat(`${username}, tôi sẽ tìm chỗ để đặt ${blockToPlaceName} xuống...`);

    let placedBlock = null;
    const maxPlacementSearchRadius = 3;
    const offsets = [{dx: 0, dz: 0}];
    for (let r = 1; r <= maxPlacementSearchRadius; r++) {
        for (let dx = -r; dx <= r; dx++) {
            for (let dz = -r; dz <= r; dz++) {
                 if (Math.abs(dx) === r || Math.abs(dz) === r) { offsets.push({dx, dz}); }
            }
        }
    }

    for (const offset of offsets) {
        const checkPos = bot.entity.position.floored().offset(offset.dx, 0, offset.dz);
        const refPos = checkPos.offset(0, -1, 0);
        const targetPos = checkPos;
        const referenceBlock = bot.blockAt(refPos);
        const targetBlock = bot.blockAt(targetPos);

        if (referenceBlock && referenceBlock.boundingBox === 'block' &&
            targetBlock && targetBlock.type === 0 && // Check if the target space is air
            bot.entity.position.distanceTo(targetPos.offset(0.5, 0.5, 0.5)) < 4.5) {
            console.log(`[PlaceBlock] Tìm thấy vị trí hợp lệ: Đặt tại ${formatCoords(targetPos)} lên trên ${referenceBlock.name} tại ${formatCoords(refPos)}`);
            try {
                await bot.equip(blockItem, 'hand');
                console.log(`[PlaceBlock] Đã trang bị ${blockToPlaceName}.`);
                await bot.placeBlock(referenceBlock, new Vec3(0, 1, 0));
                console.log("[PlaceBlock] Lệnh đặt khối đã gửi. Chờ xác nhận...");
                await bot.waitForTicks(20); // Increased wait time slightly
                const verifyBlock = bot.blockAt(targetPos);
                if (verifyBlock && verifyBlock.name === blockToPlaceName) {
                    console.log(`[PlaceBlock] Đặt và xác nhận ${blockToPlaceName} thành công tại ${formatCoords(targetPos)}.`);
                    placedBlock = verifyBlock;
                    break;
                } else {
                    console.warn(`[PlaceBlock] Đã đặt nhưng không xác nhận được ${blockToPlaceName} tại ${formatCoords(targetPos)} (Thấy: ${verifyBlock?.name}). Thử vị trí khác...`);
                    await bot.waitForTicks(5); // Small delay before next attempt
                }
            } catch (err) {
                console.error(`[PlaceBlock] Lỗi khi cố đặt ${blockToPlaceName} tại ${formatCoords(targetPos)}:`, err.message);
                 // Check for specific placement errors if needed
                if (err.message.includes('No block has been placed')) {
                    console.warn('[PlaceBlock] Lỗi không đặt được block, có thể do server lag hoặc vị trí không hợp lệ.');
                }
                await sleep(200); // Wait a bit before trying next location
            }
        }
    }

    if (placedBlock) {
        bot.chat(`Tôi đã đặt ${blockToPlaceName} tại ${formatCoords(placedBlock.position)}.`);
        return placedBlock;
    } else {
        console.error(`[PlaceBlock] Không tìm được vị trí phù hợp nào để đặt ${blockToPlaceName}.`);
        bot.chat(`Xin lỗi ${username}, tôi không tìm được chỗ nào tốt để đặt ${blockToPlaceName} xuống.`);
        return null;
    }
}

async function performManualCheck(bot, mcData, recipe, quantity, isPreliminary) {
    const checkType = isPreliminary ? "Sơ bộ" : "Chi tiết";
    console.log(`[ManualCheck - ${checkType}] Kiểm tra thủ công nguyên liệu...`);
    if (!recipe) {
        console.error(`[ManualCheck - ${checkType}] Lỗi: Không có công thức hợp lệ.`);
        return false;
    }
     if (!recipe.result || !recipe.result.count || recipe.result.count <= 0) {
         console.error(`[ManualCheck - ${checkType}] Lỗi: Công thức không có số lượng kết quả hợp lệ.`);
         return false;
     }

    let craftsNeeded = 1;
    if (!isPreliminary) {
        craftsNeeded = Math.ceil(quantity / recipe.result.count);
        console.log(`[ManualCheck - ${checkType}] Cần ${craftsNeeded} lần craft (mỗi lần tạo ${recipe.result.count}) để có ${quantity} mục tiêu.`);
    } else {
         console.log(`[ManualCheck - ${checkType}] Kiểm tra cho 1 lần craft.`);
    }

    const totalNeeded = {};
    let ingredientsSource = recipe.delta;

     if (!ingredientsSource || ingredientsSource.length === 0) {
        console.log(`[ManualCheck - ${checkType}] Không có delta, thử tính từ ingredients/inShape...`);
        ingredientsSource = [];
        const source = recipe.ingredients || (recipe.inShape ? recipe.inShape.flat() : null);
        if (source) {
            source.forEach(ingredient => {
                let id = null; let count = 1;
                if (ingredient === null || ingredient === -1) return;
                if (typeof ingredient === 'object' && ingredient !== null && !Array.isArray(ingredient)) {
                    if (ingredient.id !== undefined && ingredient.id !== -1) { id = ingredient.id; count = ingredient.count || 1; }
                    else if (ingredient.matching && ingredient.matching.length > 0) { id = ingredient.matching[0]; count = ingredient.count || 1; }
                } else if (typeof ingredient === 'number') { id = ingredient; }
                else if (Array.isArray(ingredient) && ingredient.length > 0) {
                    const firstItem = ingredient.flat()[0];
                    if (typeof firstItem === 'number' && firstItem !== -1) { id = firstItem; }
                }
                if (id !== null) ingredientsSource.push({ id: id, count: -count });
            });
        }
    }

    if (!ingredientsSource || ingredientsSource.length === 0) {
        console.error(`[ManualCheck - ${checkType}] Lỗi: Không xác định được nguyên liệu.`);
        return false;
    }

    console.log(`[ManualCheck - ${checkType}] Phân tích nguyên liệu cần:`, ingredientsSource);

    ingredientsSource.forEach(item => {
        if (item.count < 0) {
             const neededPerCraft = -item.count;
             const ingredientId = item.id;
             if (ingredientId !== null && ingredientId !== undefined && ingredientId !== -1) {
                 totalNeeded[ingredientId] = (totalNeeded[ingredientId] || 0) + (neededPerCraft * craftsNeeded);
             }
        }
    });

    console.log(`[ManualCheck - ${checkType}] Tổng nguyên liệu cần:`, totalNeeded);

    if (Object.keys(totalNeeded).length === 0 && ingredientsSource.some(i => i.count < 0 && i.id !== -1)) {
         console.warn(`[ManualCheck - ${checkType}] Tính toán rỗng dù có vẻ cần?`);
         return true;
    }
     if (Object.keys(totalNeeded).length === 0) {
         console.log(`[ManualCheck - ${checkType}] Công thức không cần nguyên liệu? OK.`);
         return true;
     }

    for (const ingredientIdStr in totalNeeded) {
        const ingredientId = parseInt(ingredientIdStr, 10);
        const requiredCount = totalNeeded[ingredientIdStr];
        const availableCount = bot.inventory.count(ingredientId, null);
        const ingredientData = mcData.items[ingredientId] || mcData.blocks[ingredientId];
        const ingredientName = ingredientData?.displayName || ingredientData?.name || `ID ${ingredientId}`;
        console.log(`[ManualCheck - ${checkType}]   - ${ingredientName} (ID ${ingredientId}): Cần ${requiredCount}, Có ${availableCount}`);
        if (availableCount < requiredCount) {
            console.log(`[ManualCheck - ${checkType}]   -> Không đủ ${ingredientName}!`);
            return false;
        }
    }

    console.log(`[ManualCheck - ${checkType}] Kiểm tra thành công.`);
    return true;
}

async function craftItem(bot, username, message, aiModel, quantityOverride = null) {
    const isSystemRequest = username === "System";
    console.log(`[Craft] === Bắt đầu craft từ ${isSystemRequest ? 'System' : username}: "${message}" ===`);

    let itemNameVi = null;
    let quantity = quantityOverride ?? 1;

    if (!quantityOverride) {
        try {
            console.log("[Craft] Bước 1: Trích xuất tên/số lượng...");
            const extractionPrompt = `Từ tin nhắn "${message}", trích xuất tên vật phẩm muốn chế tạo và số lượng. Mặc định là 1. JSON: {"itemName": "tên vật phẩm", "quantity": số lượng}. Ví dụ: "làm 5 đuốc" -> {"itemName": "đuốc", "quantity": 5}. JSON:`;
            const extractResult = await aiModel.generateContent(extractionPrompt);
            const jsonResponse = (await extractResult.response.text()).trim();
            let parsedData;
             try {
                const jsonMatch = jsonResponse.match(/\{.*\}/s);
                if (jsonMatch && jsonMatch[0]) {
                    parsedData = JSON.parse(jsonMatch[0]);
                } else {
                     const numMatch = message.match(/\d+/);
                     const potentialQuantity = numMatch ? parseInt(numMatch[0], 10) : 1;
                     const potentialName = message.replace(/\d+/, '').replace(/làm|chế tạo|cho|cái/gi, '').trim();
                     if (potentialName) {
                         itemNameVi = potentialName;
                         quantity = potentialQuantity > 0 ? potentialQuantity : 1;
                     } else { throw new Error("Fallback thất bại."); }
                }
            } catch (parseError) {
                 throw new Error(`Parse JSON/fallback lỗi: ${parseError.message}`);
            }
            if (parsedData) {
                itemNameVi = parsedData.itemName;
                quantity = parseInt(parsedData.quantity, 10);
                 if (isNaN(quantity) || quantity <= 0) { quantity = 1; }
            }
            if (!itemNameVi) throw new Error("Không trích xuất được tên.");
            quantity = Math.max(1, quantity);
            console.log(`[Craft] Bước 1: Tên="${itemNameVi}", Số lượng=${quantity}`);
        } catch (error) {
            console.error("[Craft] Lỗi trích xuất:", error);
            if (!isSystemRequest) bot.chat(`Lỗi: ${error.message}`);
            return false;
        }
    } else {
         itemNameVi = message.replace(/\d+/g, '').replace(/chế tạo|làm|craft|make/gi, '').trim();
         quantity = quantityOverride;
         console.log(`[Craft] Bước 1: Yêu cầu hệ thống/Override: Tên="${itemNameVi}", Số lượng=${quantity}`);
    }

    console.log(`[Craft] Bước 2: Dịch "${itemNameVi}" sang ID...`);
    const itemId = translateToEnglishId(itemNameVi);
    if (!itemId) {
        if (!isSystemRequest) bot.chat(`Tôi không biết "${itemNameVi}" là gì.`);
        return false;
    }
    console.log(`[Craft] Bước 2: ID: "${itemId}"`);

    console.log(`[Craft] Bước 3: Tải mcData v${bot.version}...`);
    const mcData = require('minecraft-data')(bot.version);
    if (!mcData) {
        if (!isSystemRequest) bot.chat(`Lỗi tải dữ liệu game.`);
        return false;
    }
    const itemToCraft = mcData.itemsByName[itemId] || mcData.blocksByName[itemId];
    if (!itemToCraft) {
        if (!isSystemRequest) bot.chat(`Không tìm thấy thông tin về "${itemNameVi}" (${itemId}).`);
        return false;
    }
    console.log(`[Craft] Bước 3: Chế tạo: ${itemId} (ID: ${itemToCraft.id}), Số lượng: ${quantity}`);

    console.log(`[Craft] Bước 4: Lấy công thức từ mcData...`);
    const knownRecipes = mcData.recipes[itemToCraft.id];
    if (!knownRecipes || knownRecipes.length === 0) {
        if (itemToCraft.craftingDifficulty === undefined) {
             if (!isSystemRequest) bot.chat(`${itemNameVi} hình như không chế tạo được.`);
        } else {
             if (!isSystemRequest) bot.chat(`Không tìm thấy công thức cho ${itemNameVi}.`);
        }
        return false;
    }
    const firstKnownRecipe = knownRecipes[0];
    let potentialRequiresTable = firstKnownRecipe.requiresTable;
    const itemsDefinitelyNeedingTable = ['pickaxe', 'axe', 'shovel', 'hoe', 'sword', 'helmet', 'chestplate', 'leggings', 'boots', 'furnace', 'crafting_table', 'chest', 'barrel', 'smoker', 'blast_furnace', 'shield', 'bow', 'bed', 'piston', 'sticky_piston', 'dispenser', 'dropper', 'repeater', 'comparator', 'observer', 'tnt', 'bookshelf', 'jukebox', 'note_block', 'cake', 'cookie', 'pumpkin_pie', 'beacon', 'enchanting_table', 'ender_chest', 'anvil', 'brewing_stand', 'cauldron', 'item_frame', 'flower_pot', 'armor_stand', 'banner', 'shulker_box', 'concrete', 'glazed_terracotta', 'map'];
    const itemNameLower = itemId.toLowerCase();
    const itemDisplayNameLower = itemToCraft.displayName?.toLowerCase() || '';
    const needsTableOverride = itemsDefinitelyNeedingTable.some(suffix => itemNameLower.endsWith(suffix) || itemDisplayNameLower.endsWith(suffix) || itemNameLower.startsWith(suffix));
    if (needsTableOverride && (potentialRequiresTable === undefined || potentialRequiresTable === false)) potentialRequiresTable = true;
    else if (!needsTableOverride && potentialRequiresTable === undefined) potentialRequiresTable = false;
    else if (potentialRequiresTable === undefined) potentialRequiresTable = false;
    console.log(`[Craft] Bước 4: Công thức ${potentialRequiresTable ? 'CẦN' : 'KHÔNG cần'} bàn.`);

    console.log("[Craft] Bước 5: Kiểm tra nguyên liệu sơ bộ...");
    let preliminaryCheckOK = false;
    for (const recipe of knownRecipes) {
        if (await performManualCheck(bot, mcData, recipe, 1, true)) {
            preliminaryCheckOK = true;
            break;
        }
    }
    if (!preliminaryCheckOK) {
        if (!isSystemRequest) bot.chat(`Không đủ nguyên liệu cơ bản cho ${itemNameVi}.`);
        return false;
    }
    console.log("[Craft] Bước 5: Kiểm tra sơ bộ OK.");

    let craftingTableBlock = null;
    let availableRecipes = null;

    if (potentialRequiresTable) {
        console.log("[Craft] Bước 6a: Tìm/đặt bàn chế tạo...");
        craftingTableBlock = await findNearbyBlock(bot, mcData, [CRAFTING_TABLE_ID_NAME]);
        if (craftingTableBlock) {
            if (!await gotoBlock(bot, craftingTableBlock)) {
                if (!isSystemRequest) bot.chat("Không đến được bàn, thử đặt cái mới.");
                craftingTableBlock = await placeBlockFromInventory(bot, mcData, username, CRAFTING_TABLE_ID_NAME, ensureCraftingTableInInventory);
            }
        } else {
            craftingTableBlock = await placeBlockFromInventory(bot, mcData, username, CRAFTING_TABLE_ID_NAME, ensureCraftingTableInInventory);
        }
        if (!craftingTableBlock) return false;
        console.log(`[Craft] Bước 6a: Dùng bàn tại ${formatCoords(craftingTableBlock.position)}. Lấy công thức khả thi...`);
        availableRecipes = bot.recipesFor(itemToCraft.id, null, 1, craftingTableBlock);
    } else {
        console.log("[Craft] Bước 6b: Không cần bàn. Lấy công thức khả thi...");
        availableRecipes = bot.recipesFor(itemToCraft.id, null, 1, null);
    }

    let recipeToUse = null;
    if (!availableRecipes || availableRecipes.length === 0) {
         if (!isSystemRequest) bot.chat(`Không có công thức phù hợp với nguyên liệu hiện có cho ${itemNameVi}${potentialRequiresTable ? ' (dùng bàn)' : ''}.`);
         return false;
    }
    console.log(`[Craft] Bước 7: Tìm thấy ${availableRecipes.length} công thức khả thi. Kiểm tra chi tiết...`);
    for (const recipe of availableRecipes) {
        if (await performManualCheck(bot, mcData, recipe, quantity, false)) {
            recipeToUse = recipe;
            console.log(`[Craft] Bước 7: Công thức này OK.`);
            break;
        }
    }
    if (!recipeToUse) {
        if (!isSystemRequest) bot.chat(`Không đủ nguyên liệu để làm ${quantity} ${itemNameVi}.`);
        return false;
    }
    console.log(`[Craft] Bước 7: Đã chọn công thức.`);

    if (!recipeToUse.result || !recipeToUse.result.count || recipeToUse.result.count <= 0) {
         if (!isSystemRequest) bot.chat(`Lỗi công thức của ${itemNameVi}.`);
         return false;
    }
    const craftsNeeded = Math.ceil(quantity / recipeToUse.result.count);
    console.log(`[Craft Debug] Cần ${craftsNeeded} lần craft.`);

    console.log(`[Craft] Bước 8: Bắt đầu ${craftsNeeded} lần chế tạo ${itemId}...`);
    if (!isSystemRequest) bot.chat(`Ok ${username}, bắt đầu chế tạo ${quantity} ${itemNameVi}...`);
    let itemBefore = bot.inventory.count(itemToCraft.id, null);
    let craftedSuccessfully = false;
    try {
        await bot.craft(recipeToUse, craftsNeeded, craftingTableBlock);
        await bot.waitForTicks(15 + craftsNeeded * 2);
        craftedSuccessfully = true;

        const itemAfter = bot.inventory.count(itemToCraft.id, null);
        const craftedCount = itemAfter - itemBefore;
        console.log(`[Craft Debug] Số lượng ${itemId} sau khi craft: ${itemAfter} (Trước: ${itemBefore})`);
        if (itemAfter >= itemBefore + (craftsNeeded * recipeToUse.result.count)) {
             if (!isSystemRequest) bot.chat(`${username}, đã chế tạo xong ${itemNameVi}! (Hiện có ${itemAfter})`);
        } else if (craftedCount > 0 || (itemAfter >= quantity && itemBefore < quantity)) {
             if (!isSystemRequest) bot.chat(`${username}, đã chế tạo xong ${itemNameVi}! (Hiện có ${itemAfter})`);
        } else if (itemAfter === itemBefore && itemAfter > 0) {
             if (!isSystemRequest) bot.chat(`${username}, đã thử chế tạo ${itemNameVi}, nhưng số lượng không đổi. (Hiện có ${itemAfter})`);
             craftedSuccessfully = false;
        } else {
             if (!isSystemRequest) bot.chat(`Hmm ${username}, đã thử chế tạo ${itemNameVi}, nhưng không chắc nó vào túi đồ chưa.`);
             craftedSuccessfully = false;
        }

    } catch (err) {
        console.error(`[Craft] Lỗi khi gọi bot.craft cho ${itemId}:`, err);
        if (!isSystemRequest) bot.chat(`Lỗi khi chế tạo ${itemNameVi}.`);
        if (err.message) {
            const lowerMsg = err.message.toLowerCase();
            if (lowerMsg.includes('missing') || lowerMsg.includes('not enough')) {
                 if (!isSystemRequest) bot.chat(`(Lỗi: Thiếu nguyên liệu?)`);
            } else if (lowerMsg.includes('no space')) {
                 if (!isSystemRequest) bot.chat(`(Lỗi: Túi đồ đầy.)`);
            } else if (lowerMsg.includes('recipe not found') || lowerMsg.includes('invalid recipe')) {
                 if (!isSystemRequest) bot.chat(`(Lỗi: Công thức không hợp lệ?)`);
            } else {
                 if (!isSystemRequest) bot.chat(`(Lỗi: ${err.message})`);
            }
        }
        craftedSuccessfully = false;
    } finally {
         console.log(`[Craft] === Kết thúc craft cho ${isSystemRequest ? 'System' : username}: "${message}" ===`);
    }
    return craftedSuccessfully;
}


async function ensureFurnaceAvailable(bot, mcData, username, requiredType = FURNACE_ID_NAME) {
    const furnaceItemData = mcData.itemsByName[requiredType];
    if (!furnaceItemData) {
        console.error(`[EnsureFurnace] Không tìm thấy dữ liệu item cho ${requiredType}!`);
        if (username !== "System") bot.chat(`Lỗi dữ liệu game cho ${requiredType}.`);
        return false;
    }
    let furnaceItem = bot.inventory.findInventoryItem(furnaceItemData.id, null);
    if (furnaceItem) {
        console.log(`[EnsureFurnace] Tìm thấy ${furnaceItem.count} ${requiredType} trong túi.`);
        return true;
    }

    if (requiredType === FURNACE_ID_NAME) {
        console.log(`[EnsureFurnace] Không có ${requiredType}, thử chế tạo...`);
        if (username !== "System") bot.chat(`${username}, tôi không có lò nung, để làm một cái...`);

        const cobbleData = mcData.itemsByName[COBBLESTONE_ID_NAME];
        if (!cobbleData) { console.error("[EnsureFurnace] Không tìm thấy cobblestone data!"); return false; }
        const cobbleCount = bot.inventory.count(cobbleData.id, null);
        console.log(`[EnsureFurnace] Đá cuội: ${cobbleCount}`);

        if (cobbleCount < 8) {
            console.log("[EnsureFurnace] Không đủ đá cuội (cần 8).");
            if (username !== "System") bot.chat(`Không đủ đá cuội làm lò nung.`);
            return false;
        }

        console.log("[EnsureFurnace] Yêu cầu chế tạo lò nung...");
        const crafted = await craftItem(bot, "System", `chế tạo ${FURNACE_ID_NAME}`, null, 1);
        if (crafted) {
            console.log("[EnsureFurnace] Chế tạo lò nung thành công!");
            await sleep(500);
            return true;
        } else {
            console.error("[EnsureFurnace] Chế tạo lò nung thất bại.");
            if (username !== "System") bot.chat("Thử làm lò nung thất bại.");
            return false;
        }
    } else {
        console.log(`[EnsureFurnace] Không có ${requiredType} và chưa hỗ trợ craft.`);
        if (username !== "System") bot.chat(`Tôi không có ${requiredType} trong túi.`);
        return false;
    }
}

function findAvailableFuel(bot, mcData) {
    console.log("[FuelCheck] Tìm nhiên liệu...");
    const fuelItems = mcData.itemsArray.filter(item =>
        bot.registry.tags[FUEL_TAG]?.includes(item.id) ||
        bot.registry.tags[LOGS_TAG]?.includes(item.id)
    );

    for (const fuelItem of fuelItems) {
        const count = bot.inventory.count(fuelItem.id, null);
        if (count > 0) {
            console.log(`[FuelCheck] Tìm thấy ${count} ${fuelItem.name}`);
            return { item: fuelItem, count: count };
        }
    }
    console.log("[FuelCheck] Không tìm thấy nhiên liệu.");
    return null;
}

async function smeltItem(bot, username, message, aiModel, quantityOverride = null) {
    const isSystemRequest = username === "System";
    console.log(`[Smelt] === Bắt đầu smelt từ ${isSystemRequest ? 'System' : username}: "${message}" ===`);

    let itemToSmeltVi = null;
    let quantity = quantityOverride ?? 1;

    if (!quantityOverride) {
        try {
            console.log("[Smelt] Bước 1: Trích xuất tên/số lượng (nung)...");
             const extractionPrompt = `Từ tin nhắn "${message}", trích xuất tên vật phẩm muốn NUNG/NẤU và số lượng. Mặc định là 1. JSON: {"itemName": "tên vật phẩm", "quantity": số lượng}. Ví dụ: "nung 10 sắt" -> {"itemName": "sắt", "quantity": 10}. JSON:`;
             const extractResult = await aiModel.generateContent(extractionPrompt);
             const jsonResponse = (await extractResult.response.text()).trim();
             let parsedData;
              try {
                 const jsonMatch = jsonResponse.match(/\{.*\}/s);
                 if (jsonMatch && jsonMatch[0]) {
                     parsedData = JSON.parse(jsonMatch[0]);
                 } else {
                      const numMatch = message.match(/\d+/);
                      const potentialQuantity = numMatch ? parseInt(numMatch[0], 10) : 1;
                      const potentialName = message.replace(/\d+/, '').replace(/nung|nấu|smelt|cook/gi, '').trim();
                      if (potentialName) {
                          itemToSmeltVi = potentialName;
                          quantity = potentialQuantity > 0 ? potentialQuantity : 1;
                      } else { throw new Error("Fallback thất bại."); }
                 }
             } catch (parseError) {
                  throw new Error(`Parse JSON/fallback lỗi: ${parseError.message}`);
             }
             if (parsedData) {
                 itemToSmeltVi = parsedData.itemName;
                 quantity = parseInt(parsedData.quantity, 10);
                  if (isNaN(quantity) || quantity <= 0) { quantity = 1; }
             }
             if (!itemToSmeltVi) throw new Error("Không trích xuất được tên.");
             quantity = Math.max(1, quantity);
             console.log(`[Smelt] Bước 1: Nung="${itemToSmeltVi}", Số lượng=${quantity}`);
        } catch (error) {
            console.error("[Smelt] Lỗi trích xuất:", error);
            if (!isSystemRequest) bot.chat(`Lỗi: ${error.message}`);
            return false;
        }
    } else {
         itemToSmeltVi = message.replace(/\d+/g, '').replace(/nung|nấu|smelt|cook/gi, '').trim();
         quantity = quantityOverride;
         console.log(`[Smelt] Bước 1: Yêu cầu hệ thống/Override: Nung="${itemToSmeltVi}", Số lượng=${quantity}`);
    }

    console.log(`[Smelt] Bước 2: Dịch "${itemToSmeltVi}" & tìm công thức nung...`);
    const inputItemId = translateToEnglishId(itemToSmeltVi);
    if (!inputItemId) {
        if (!isSystemRequest) bot.chat(`Tôi không biết "${itemToSmeltVi}" là gì.`);
        return false;
    }

    const mcData = require('minecraft-data')(bot.version);
    const inputItemData = mcData.itemsByName[inputItemId] || mcData.blocksByName[inputItemId];
    if (!inputItemData) {
        if (!isSystemRequest) bot.chat(`Không tìm thấy dữ liệu cho "${itemToSmeltVi}" (${inputItemId}).`);
        return false;
    }

    // Cấu trúc dữ liệu nung có thể khác nhau giữa các phiên bản mcData
    // Đoạn code này giả định có một cách lấy công thức nung (cần điều chỉnh nếu cần)
    let smeltingRecipes = [];
    if(mcData.smelting) { // Check for older mcData structure
         const recipe = mcData.smelting.find(r => r.input === inputItemData.id);
         if(recipe) smeltingRecipes.push({ ...recipe, type: 'minecraft:smelting', result: { id: recipe.output, count: 1}, cookTime: 200 }); // Adapt structure
    } else if (mcData.recipes) { // Check newer structure (more complex)
         for (const id in mcData.recipes) {
              const recipesForId = mcData.recipes[id];
              if(Array.isArray(recipesForId)) {
                   recipesForId.forEach(r => {
                       // Check if recipe input matches our item (simplified check)
                       let matchesInput = false;
                       if(r.ingredients && r.ingredients.length === 1) {
                           const ing = r.ingredients[0];
                           if(typeof ing === 'number' && ing === inputItemData.id) matchesInput = true;
                           if(typeof ing === 'object' && ing?.id === inputItemData.id) matchesInput = true;
                           if(typeof ing === 'object' && Array.isArray(ing?.matching) && ing.matching.includes(inputItemData.id)) matchesInput = true;
                       } else if (r.ingredient && (r.ingredient.item === inputItemId || r.ingredient.tag && bot.registry.tags[r.ingredient.tag]?.includes(inputItemData.id))) {
                            matchesInput = true; // Structure for furnace specific recipes
                       }

                       if(matchesInput && (r.type === 'minecraft:smelting' || r.type === 'minecraft:blasting' || r.type === 'minecraft:smoking')) {
                            // Ensure result structure is consistent
                            let resultObj = {};
                            if(typeof r.result === 'string') { // e.g. "minecraft:iron_ingot"
                                const resultData = mcData.itemsByName[r.result.replace('minecraft:', '')] || mcData.blocksByName[r.result.replace('minecraft:', '')];
                                if(resultData) resultObj = { id: resultData.id, count: r.count ?? 1 };
                            } else if (typeof r.result === 'object' && r.result.item) {
                                const resultData = mcData.itemsByName[r.result.item.replace('minecraft:', '')] || mcData.blocksByName[r.result.item.replace('minecraft:', '')];
                                if(resultData) resultObj = { id: resultData.id, count: r.result.count ?? 1 };
                            } else if (typeof r.result === 'object' && r.result.id) { // Already has id
                                 resultObj = { id: r.result.id, count: r.result.count ?? 1 };
                            }

                           if(resultObj.id !== undefined) {
                                smeltingRecipes.push({ ...r, result: resultObj, inputId: inputItemData.id }); // Add inputId for clarity
                           }
                       }
                   });
              }
         }
    }

    const applicableRecipes = smeltingRecipes.filter(r => r.inputId === inputItemData.id);
    const blastingRecipe = applicableRecipes.find(r => r.type === 'minecraft:blasting');
    const smokingRecipe = applicableRecipes.find(r => r.type === 'minecraft:smoking');
    const regularRecipe = applicableRecipes.find(r => r.type === 'minecraft:smelting');

    let recipeToUse = null;
    let requiredFurnaceType = FURNACE_ID_NAME;
    if (blastingRecipe) { recipeToUse = blastingRecipe; requiredFurnaceType = BLAST_FURNACE_ID_NAME; }
    else if (smokingRecipe) { recipeToUse = smokingRecipe; requiredFurnaceType = SMOKER_ID_NAME; }
    else if (regularRecipe) { recipeToUse = regularRecipe; requiredFurnaceType = FURNACE_ID_NAME; }

    if (!recipeToUse || !recipeToUse.result || !recipeToUse.result.id) {
        if (!isSystemRequest) bot.chat(`${itemToSmeltVi} hình như không nung được.`);
        return false;
    }

    const outputItemData = mcData.items[recipeToUse.result.id] || mcData.blocks[recipeToUse.result.id];
    if (!outputItemData) {
         if (!isSystemRequest) bot.chat(`Lỗi: Không tìm thấy dữ liệu sản phẩm nung.`);
        return false;
    }
    const outputItemId = outputItemData.id;
    const outputItemName = outputItemData.name;
    const cookTimeTicks = recipeToUse.experience !== undefined ? (recipeToUse.cookingtime ?? 200) : (recipeToUse.cookTime ?? 200); // Adapt to different mcData structures for cook time

    console.log(`[Smelt] Bước 2: Nung ${quantity} ${inputItemId} -> ${outputItemName} (ID: ${outputItemId}) bằng ${requiredFurnaceType}. Time: ${cookTimeTicks} ticks.`);

    console.log("[Smelt] Bước 3: Kiểm tra nguyên liệu đầu vào...");
    const inputAvailable = bot.inventory.count(inputItemData.id, null);
    if (inputAvailable < quantity) {
        if (!isSystemRequest) bot.chat(`Chỉ có ${inputAvailable}/${quantity} ${itemToSmeltVi} để nung.`);
        return false;
    }
    console.log(`[Smelt] Có ${inputAvailable}/${quantity} ${inputItemId}.`);

    console.log("[Smelt] Bước 4: Kiểm tra nhiên liệu...");
    const fuelInfo = findAvailableFuel(bot, mcData);
    if (!fuelInfo) {
        if (!isSystemRequest) bot.chat(`Không có nhiên liệu để nung.`);
        return false;
    }
    console.log(`[Smelt] Có nhiên liệu: ${fuelInfo.item.name} (${fuelInfo.count}).`);

    console.log(`[Smelt] Bước 5: Tìm/đặt ${requiredFurnaceType}...`);
    let furnaceBlock = await findNearbyBlock(bot, mcData, [requiredFurnaceType]);

    if (furnaceBlock) {
        if (!await gotoBlock(bot, furnaceBlock, 2.5)) {
            if (!isSystemRequest) bot.chat(`Không đến được ${requiredFurnaceType}, thử đặt cái mới.`);
            // Ensure function needs to accept the specific furnace type
            furnaceBlock = await placeBlockFromInventory(bot, mcData, username, requiredFurnaceType, (b, mcd, user, fType) => ensureFurnaceAvailable(b, mcd, user, fType));
        }
    } else {
        furnaceBlock = await placeBlockFromInventory(bot, mcData, username, requiredFurnaceType, (b, mcd, user, fType) => ensureFurnaceAvailable(b, mcd, user, fType));
    }

    if (!furnaceBlock) return false;
    console.log(`[Smelt] Sẵn sàng dùng ${requiredFurnaceType} tại ${formatCoords(furnaceBlock.position)}.`);

    if (!isSystemRequest) bot.chat(`Ok ${username}, bắt đầu nung ${quantity} ${itemToSmeltVi}...`);
    let remainingQuantity = quantity;
    let totalSmelted = 0;
    let furnaceWindow = null;
    let success = false;

    try {
        while (remainingQuantity > 0) {
            console.log(`[Smelt Loop] Cần nung: ${remainingQuantity}. Mở lò...`);
            furnaceWindow = await bot.openFurnace(furnaceBlock);

            const currentFuel = findAvailableFuel(bot, mcData);
            if (!currentFuel) {
                console.log("[Smelt Loop] Hết nhiên liệu!");
                if (!isSystemRequest) bot.chat("Hết nhiên liệu rồi!");
                break;
            }
             const currentInput = bot.inventory.count(inputItemData.id, null);
             if (currentInput === 0) {
                 console.log("[Smelt Loop] Hết nguyên liệu đầu vào!");
                 break;
             }

            const amountToPutIn = Math.min(remainingQuantity, currentInput, inputItemData.stackSize);
            const fuelToPutIn = 1; // Nạp 1 nhiên liệu mỗi lần cho đơn giản, có thể tối ưu sau

             console.log(`[Smelt Loop] Nạp ${amountToPutIn} input, ${fuelToPutIn} fuel...`);
             // Nạp fuel trước nếu ô fuel trống hoặc sắp hết
             if(!furnaceWindow.fuelItem() || furnaceWindow.fuel < 5) { // Arbitrary low fuel threshold
                 try {
                     await furnaceWindow.putFuel(currentFuel.item.id, null, fuelToPutIn);
                     await sleep(250);
                 } catch (fuelErr) { console.error("Lỗi nạp fuel:", fuelErr.message); await sleep(200); }
             }
             try {
                await furnaceWindow.putInput(inputItemData.id, null, amountToPutIn);
                await sleep(250);
             } catch (inputErr) { console.error("Lỗi nạp input:", inputErr.message); await sleep(200); break;}


            console.log(`[Smelt Loop] Chờ nung ${amountToPutIn} item...`);
            let smeltedInThisBatch = 0;
            const checkInterval = 500;
             // Estimate max wait slightly longer than needed per item + buffer
            const maxWaitTime = ((cookTimeTicks / 20) * amountToPutIn * 1.1 * 1000) + 5000;
            let waitedTime = 0;
            let lastOutputCheckTime = Date.now();

            while (smeltedInThisBatch < amountToPutIn && waitedTime < maxWaitTime) {
                await sleep(checkInterval);
                waitedTime += checkInterval;

                // Lấy output định kỳ
                 if (Date.now() - lastOutputCheckTime > 1000) { // Check output every second or so
                     const outputSlotItem = furnaceWindow.outputItem();
                     if (outputSlotItem && outputSlotItem.type === outputItemId && outputSlotItem.count > 0) {
                         const countInSlot = outputSlotItem.count;
                         console.log(`[Smelt Wait] Có ${countInSlot} output. Lấy ra...`);
                         try {
                             await furnaceWindow.takeOutput(null);
                             await sleep(150); // Small delay after taking output
                             smeltedInThisBatch += countInSlot;
                             totalSmelted += countInSlot;
                             // IMPORTANT: Update remainingQuantity based on totalSmelted, not batch
                             remainingQuantity = Math.max(0, quantity - totalSmelted);
                             console.log(`[Smelt Wait] Lấy ${countInSlot}. Tổng: ${totalSmelted}. Còn lại: ${remainingQuantity}`);
                             lastOutputCheckTime = Date.now(); // Reset check timer after successful take
                             if (remainingQuantity <= 0) break; // Đã xong
                         } catch (takeErr) {
                             console.error("[Smelt Wait] Lỗi lấy output:", takeErr.message);
                             if (takeErr.message.toLowerCase().includes('space')) {
                                  if (!isSystemRequest) bot.chat("Túi đồ đầy, không lấy đồ nung ra được!");
                                   // Optionally break or implement item dropping logic here
                             }
                              // Don't reset lastOutputCheckTime, try again soon
                             await sleep(500); // Wait before retrying take
                             // Consider breaking if take error persists
                         }
                     } else {
                         lastOutputCheckTime = Date.now(); // Reset check timer even if no output
                     }

                     // Check if furnace stopped unexpectedly (no fuel or input left in furnace window)
                     if (!furnaceWindow.inputItem() && !furnaceWindow.fuelItem() && !furnaceWindow.outputItem()) {
                         console.warn("[Smelt Wait] Lò có vẻ trống rỗng và không hoạt động. Dừng chờ.");
                         break;
                     }
                      if (furnaceWindow.fuel === 0 && !furnaceWindow.outputItem() && smeltedInThisBatch < amountToPutIn) {
                           console.warn("[Smelt Wait] Lò hết nhiên liệu giữa chừng batch.");
                           break; // Exit wait loop for this batch
                      }

                 }
                 if (remainingQuantity <= 0) break; // Exit wait loop if already done
            }


             console.log(`[Smelt Loop] Batch kết thúc. Nung được: ${smeltedInThisBatch}/${amountToPutIn}. Tổng: ${totalSmelted}. Chờ: ${waitedTime}ms`);

            await furnaceWindow.close();
            furnaceWindow = null;
            await sleep(300);

            if (totalSmelted >= quantity) break;
            if (smeltedInThisBatch === 0 && waitedTime >= maxWaitTime) {
                 console.warn("[Smelt Loop] Hết giờ chờ nhưng không nung được gì.");
                 break;
            }
             if (smeltedInThisBatch < amountToPutIn && remainingQuantity > 0) {
                 console.warn("[Smelt Loop] Không nung hết batch, có thể do lỗi/hết fuel/input.");
                  // Check inventory again before breaking loop entirely
                  const currentInputAfterBatch = bot.inventory.count(inputItemData.id, null);
                  const currentFuelAfterBatch = findAvailableFuel(bot, mcData);
                  if (currentInputAfterBatch === 0 || !currentFuelAfterBatch) {
                      console.log("[Smelt Loop] Xác nhận hết input hoặc fuel trong inventory.");
                      break; // Stop the whole process
                  } else {
                       console.log("[Smelt Loop] Vẫn còn input/fuel, có thể do lỗi tạm thời. Thử lại batch sau.");
                       await sleep(1000); // Wait before potentially retrying
                  }
                 // Removed break here to potentially allow retrying the loop if resources still exist
            }

        }

        if (totalSmelted >= quantity) {
             console.log(`[Smelt] Nung thành công ${totalSmelted} ${outputItemName}.`);
             if (!isSystemRequest) bot.chat(`${username}, đã nung xong ${totalSmelted} ${itemToSmeltVi} thành ${outputItemName}!`);
             success = true;
        } else {
             console.log(`[Smelt] Kết thúc. Nung được ${totalSmelted}/${quantity} ${outputItemName}.`);
             if (!isSystemRequest) bot.chat(`${username}, chỉ nung được ${totalSmelted}/${quantity} ${itemToSmeltVi}.`);
             success = totalSmelted > 0;
        }

    } catch (err) {
        console.error("[Smelt] Lỗi nghiêm trọng khi nung:", err);
        if (!isSystemRequest) bot.chat(`Lỗi khi nung ${itemToSmeltVi}: ${err.message}`);
        success = false;
    } finally {
        if (furnaceWindow) {
            try { await furnaceWindow.close(); } catch (closeErr) { console.warn("Lỗi đóng lò sót:", closeErr.message); }
        }
        console.log(`[Smelt] === Kết thúc smelt cho ${isSystemRequest ? 'System' : username}: "${message}" ===`);
    }

    return success;
}

module.exports = {
    craftItem,
    smeltItem,
};

// --- END OF FILE craft.js ---